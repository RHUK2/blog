---
folderName: js_note
updatedAt: 2024-10-08
title: 자바스크립트 노트
tag: javascript
isPublished: true
---

# 자바스크립트 노트

- [논리 연산자 단락 평가](#논리-연산자-단락-평가)
- [배열 vs 이터러블 객체 vs 유사배열 객체](#배열-vs-이터러블-객체-vs-유사배열-객체)
- [없는 객체 참조 에러](#없는-객체-참조-에러)
- [2차원 배열 생성 시 Array.fill](#2차원-배열-생성-시-arrayfill)
- [인수 vs 인자](#인수-vs-인자)
- [순수 함수 vs 비순수 함수](#순수-함수-vs-비순수-함수)
- [값, 리터럴, 표현식, 문](#값-리터럴-표현식-문)
- [parse](#parse)
- [자바스크립트 값의 종류](#자바스크립트-값의-종류)
- [sort](#sort)
- [시간 구하기](#시간-구하기)
- [encodeURI encodeURIComponent](#encodeuri-encodeuricomponent)
- [Number() vs parseInt()](#number-vs-parseint)
- [구조 분해 할당](#구조-분해-할당)
- [일급 객체](#일급-객체)

## 논리 연산자 단락 평가

```ts
const a = null || null || null || 'end'

console.log(a) // 'end'

const b = 'value' && 'value' && 'value' && 'end'

console.log(b) 'end'
```

논리 연산자 `||`는 단락 평가 시 `null`, `undefined`, `''`, `0`, `NaN`, `false` 값을 만나면 다음으로 이동하고 만나지 않으면 해당 값을 출력한다.

논리 연산자 `&&`는 단락 평가 시 `null`, `undefined`, `''`, `0`, `NaN`, `false` 값을 만나면 해당 값을 출력하고 만나지 않으면 다음으로 이동한다.

## 배열 vs 이터러블 객체 vs 유사배열 객체

이터러블: 심볼 이터레이터를 포함하며 for in 구문 사용 가능한 객체
유사배열 객체: 인덱스와 length 프로퍼티가 있으나 배열 메서드를 사용할 수 없는 객체

위 두 객체는 배열이 아니기 때문에 Array.from으로 배열로 만들어서 사용 가능

## 없는 객체 참조 에러

```ts
if(window){...} // window is not definde 에러발생

if(typeof window !== undefined) {...} // 정의되지않은 window의 타입이기떄문에 undefied가 발생 -> 에러가 발생하지 않습니다.
```

## 2차원 배열 생성 시 Array.fill

```ts
Array(100).fill(Array(100).fill(0));

Array.from({ length: 100 }, () => Array(100).fill(0));
```

`fill` 메서드의 인수는 배열을 채울 값이다. 배열의 모든 요소는 이 정확한 값이 된다. 값이 객체인 경우 배열의 각 슬롯은 해당 객체를 참조한다.

## 인수 vs 인자

| 구분      | 인수(Argument)                | 인자(Parameter)                    |
| --------- | ----------------------------- | ---------------------------------- |
| 정의      | 함수 호출 시 전달되는 실제 값 | 함수 선언 시 정의되는 변수         |
| 예시      | `sum(3, 5)`에서 `3`과 `5`     | `function sum(a, b)`에서 `a`와 `b` |
| 동적 특성 | 런타임에 결정됨               | 컴파일 타임에 결정됨               |

## 순수 함수 vs 비순수 함수

순수 함수:

- 입력값에 의해서만 결과가 결정되며, 외부 상태를 변경하지 않는다.

```ts
function add(a, b) {
  return a + b;
}
```

비순수 함수:

- 외부 상태에 의존하거나 외부 상태를 변경할 수 있으며, 같은 입력값에 대해 항상 같은 결과를 보장하지 않는다.

```ts
let count = 0;

function increment() {
  count += 1;
  return count;
}
```

## 값, 리터럴, 표현식, 문

| 종류               | 설명                                                                                                                                                                                                                                                                     |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 값(Value)          | 표현식이 평가되어 생성된 결과                                                                                                                                                                                                                                            |
| 리터럴(Literal)    | 다양한 자료형을 가진 값을 생성하려면 이를 텍스트로 구분 짓는 것이 필요한데, 이를 위해 미리 약속된 표기법 규칙을 말한다.                                                                                                                                                  |
| 표현식(Expression) | 표현식은 값을 생성하거나 조작하는 코드 구문이다. 표현식은 값, 변수, 리터럴, 연산자, 함수 호출 등의 조합으로 구성될 수 있다. 표현식은 평가되어 값을 반환한다.                                                                                                             |
| 문(Statement)      | 문은 프로그램에서 실행되는 동작이나 작업을 나타낸다. 문은 프로그램의 동작을 제어하거나 조작하는 데 사용된다. 문은 변수 선언, 할당, 조건문(`if`/`else`), 반복문(`for`, `while`), 함수 선언 등의 구조를 가질 수 있습니다. 문은 세미콜론(`;`)으로 끝나는 것이 일반적입니다. |

## parse

보통 라이브러리는 여러가지 메서드를 가진 거대한 객체로 구성이 되고, 해당 객체에 변경할 데이터를 넣은 후 여러 메서드를 사용하여 원하는 형태의 데이터를 얻어낼 수 있다. 반대로 데이터를 기반으로 거대한 객체를 구성할 때 사용하는 것이 `parse()` 파싱 관련 메서드이다. 개발을 하다보면 데이터를 다시 조작해서 다른 데이터를 얻어내고 싶을 경우가 있을 것이다. 이런 경우 데이터를 파싱해서 거대한 객체를 다시 만들어내고 데이터를 바탕으로 만들어진 거대한 객체를 통해 다시 사용자가 원하는 형태의 데이터를 출력한다.

## 자바스크립트 값의 종류

|             | `typeof`    | 원시값 | 특이사항 | 설명                                                                               |
| ----------- | ----------- | ------ | -------- | ---------------------------------------------------------------------------------- |
| `null`      | "object"    | O      | X        | `null`의 `typeof` 연산은 "object"인데, 이는 언어상 오류다. `null`은 객체가 아니다. |
| `undefined` | "undefined" | O      | X        |                                                                                    |
| Boolean     | "boolean"   | O      | X        |                                                                                    |
| Number      | "number"    | O      | X        |                                                                                    |
| `NaN`       | "number"    | O      | X        | `NaN === NaN`은 같지 않다.                                                         |
| `Infinity`  | "number"    | O      | X        |                                                                                    |
| BigInt      | "number"    | O      | X        |                                                                                    |
| String      | "string"    | O      | X        |                                                                                    |
| Symbol      | "symbol"    | O      | X        |                                                                                    |
| Object      | "object"    | X      | O        |                                                                                    |
| Array       | "object"    | X      | O        |                                                                                    |
| Function    | "function"  | X      | O        |                                                                                    |

## sort

배열은 각 문자의 유니 코드 코드 포인트 값에 따라 정렬되기 때문에 숫자 정렬이 생각한대로 정렬되지 않을 수 있다. 원 배열이 정렬되며, 복사본이 만들어지는 것이 아니다.

`compareFunction(a, b) < 0`인 경우, `a`를 `b`보다 낮은 인덱스로 정렬한다. 즉, `a`가 먼저 온다.
`compareFunction(a, b) === 0`인 경우, `a`와 `b`를 서로에 대해 변경하지 않는다.
`compareFunction(a, b) > 0`인 경우, `b`를 `a`보다 낮은 인덱스로 정렬한다. 즉, `b`가 먼저 온다.

## 시간 구하기

10분짜리 오디오 초로 변환: 600초

번역 걸리는 시간: 15초

오디오 초로 번역 시간을 알아내기: 600 / x = 15

x = 40, 600을 40으로 나누면 15초 나옴

15초를 interval 0.2초 간격으로 나누면 총 75회 카운트

75회 카운트 동안 100퍼센트를 채우려면 1.333...%씩

보더 길이를 채우려면 보더 총 길이 / 75

## encodeURI encodeURIComponent

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/encodeURI

## Number() vs parseInt()

## 구조 분해 할당

구조 분해 할당 후 기본값을 설정하는 경우, 해당 값이 `undefined`인 경우에만 기본값이 적용된다.

```ts
const {
  a = 1,
  b = 2,
  c = 3,
  d = 4,
} = {
  a: null,
  b: undefined,
  c: 3,
  d: 4,
};

console.log(a, b, c, d); // null 2 3 4
```

## 일급 객체

일급 객체(First-class Object)는 프로그래밍 언어에서 특정 조건을 만족하는 객체를 지칭하는 용어입니다.

주요 조건은 다음과 같습니다:

1. 변수에 할당 가능
2. 함수의 인자로 전달 가능
3. 함수의 반환값으로 사용 가능
4. 자료구조(배열, 객체 등)에 저장 가능

JavaScript에서 함수는 일급 객체의 조건을 모두 만족합니다. 예를 들어:

```ts
// 1. 변수에 할당
const foo = function () {
  console.log('Hello');
};

// 2. 함수의 인자로 전달
function bar(func) {
  func();
}
bar(foo);

// 3. 함수의 반환값으로 사용
function baz() {
  return function () {
    console.log('World');
  };
}
const qux = baz();
qux();

// 4. 자료구조에 저장
const arr = [foo, qux];
arr.forEach((func) => func());
```

이처럼 JavaScript에서 함수는 일급 객체로서 다양한 방식으로 활용될 수 있습니다. 이러한 특성은 고차 함수, 클로저, 콜백 패턴 등 함수형 프로그래밍 기법을 가능하게 하는 기반이 됩니다.
