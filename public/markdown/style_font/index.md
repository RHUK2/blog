---
folderName: style_font
updatedAt: 2025-02-06
title: Font
tag: style
isPublished: false
---

# Font

- [font-family](#font-family)
- [font-face](#font-face)
- [rem, em](#rem-em)
- [text-overflow 속성 적용하기](#text-overflow-속성-적용하기)
  - [1. **아이콘 SVG 파일**](#1-아이콘-svg-파일)
    - [**장점:**](#장점)
    - [**단점:**](#단점)
  - [2. **웹폰트**](#2-웹폰트)
    - [**장점:**](#장점-1)
    - [**단점:**](#단점-1)
  - [**결론**](#결론)
  - [**1. `cmap` 테이블의 역할**](#1-cmap-테이블의-역할)
  - [**2. `cmap` 테이블의 구성**](#2-cmap-테이블의-구성)
  - [**3. `cmap` 테이블을 통한 PUA 매핑 과정**](#3-cmap-테이블을-통한-pua-매핑-과정)
  - [**4. 예시**](#4-예시)
  - [**5. `cmap` 테이블의 중요성**](#5-cmap-테이블의-중요성)
  - [**결론**](#결론-1)
- [🔹 1. **웹 폰트의 동작 방식**](#-1-웹-폰트의-동작-방식)
- [🔹 2. **아이콘 이름(human-readable label)과 유니코드 매핑**](#-2-아이콘-이름human-readable-label과-유니코드-매핑)
  - [❓ 하지만 왜 우리가 직접 `&#xE88A;`라고 쓰지 않아도 될까요?](#-하지만-왜-우리가-직접-xe88a라고-쓰지-않아도-될까요)
- [🔹 3. **CSS에서 `font-feature-settings: 'liga' 1;` (합자 사용)**](#-3-css에서-font-feature-settings-liga-1-합자-사용)
- [🔹 4. **예제: 직접 유니코드 값 활용하기**](#-4-예제-직접-유니코드-값-활용하기)
- [🔹 5. **머티리얼 아이콘과 유니코드 매핑 목록 확인 방법**](#-5-머티리얼-아이콘과-유니코드-매핑-목록-확인-방법)
- [🎯 **정리**](#-정리)
  - [🚀 **결론**](#-결론)

## font-family

- `font-family` 설정이 따로 없다면, 기본적으로 각 운영체제의 설치된 시스템 기본 글꼴을 사용하게 된다.
- 일반적으로 사용하려는 폰트명과 해당 글꼴이 없는 경우 대체할 폰트명을 나열한다.
- 폰트명에 띄어쓰기가 존재하면 따옴표로 감싸주어야 인식한다.

```css
body {
  font-family: Times, 'Times New Roman', Georgia, serif;
}
```

## font-face

- 로컬 컴퓨터에 설치된 폰트뿐 아니라 외부 리소스를 가져와서 폰트를 정의하기 위해 사용된다.
- `local()`은 로컬 컴퓨터에 설치된 폰트를 가리키기 위해 사용된다.
- `url()`은 외부 리소스(폰트)를 가리키기 위해 사용된다.
- `format()` 폰트 파일의 확장자를 명시하기 위해 사용된다.

```css
/* ... */
@font-face {
  font-family: 'Pretendard';
  font-weight: 600;
  font-display: swap;
  src:
    local('Pretendard SemiBold'),
    url('/fonts/Pretendard-SemiBold.subset.woff2') format('woff2'),
    url('/fonts/Pretendard-SemiBold.subset.woff') format('woff');
}
@font-face {
  font-family: 'Pretendard';
  font-weight: 500;
  font-display: swap;
  src:
    local('Pretendard Medium'),
    url('/fonts/Pretendard-Medium.subset.woff2') format('woff2'),
    url('/fonts/Pretendard-Medium.subset.woff') format('woff');
}
/* ... */

body {
  font-family: Pretendard, Times, 'Times New Roman', Georgia, serif;
}
```

## rem, em

```js
button: {
      fontWeight: 600,
      fontSize: '0.875rem',
      lineHeight: '1.4em',
      letterSpacing: '0em',
      fontFamily: 'inherit',
      textTransform: 'none',
    },
```

<!-- todo: 내용 보완 필요 -->

```css
html {
  font-size: 62.5%;
}
```

폰트는 `rem`으로 관리하되, 계산이 용이하도록 `html`에 `font-size: 62.5%`를 설정해 `1rem=10px`로 관리한다.

## text-overflow 속성 적용하기

```css
div {
  display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: eillipsis;
}
```

일반적으로 텍스트가 오버플로우 되려면 띄어쓰기 없이 글자 길이가 부모 박스보다 길어야 하는데, `white-space`가 `normal`이 기본값으로 설정되어 있기 때문에 자동 줄바꿈이 일어나 오버플로우가 빈번하게 발생하지는 않는다. 그래서 `white-space`를 `nowrap` 이나 `pre`로 바꿔 자동 줄바꿈을 제거해 오버플로우를 발생시킨다.

발생한 오버플로우는 `overflow: hidden`으로 가려버리고 이후에 `text-overflow: eillipsis`를 적용해 해당 텍스트의 `...`을 적용한다.

이 방식은 데이터를 자르기 때문에 작은 화면에서는 데이터를 모두 확인할 수 없기 때문에 반응형을 통해 데이터를 최대한 보여주는 방식으로 해결하는 것이 사용자 경험에 좋은 것 같다.

### 1. **아이콘 SVG 파일**

#### **장점:**

- **유연성**: SVG 파일은 XML 기반의 벡터 이미지 포맷으로, CSS를 통해 색상, 크기, 애니메이션 등을 자유롭게 조정할 수 있습니다. 또한, 이미지 자체를 쉽게 수정하거나 조정할 수 있습니다.
- **접근성**: SVG는 `<img>` 태그, `<svg>` 태그, 또는 CSS 배경 이미지로 사용될 수 있으며, 접근성을 위한 ARIA 레이블을 추가하기도 쉽습니다.
- **품질**: SVG는 벡터 이미지이기 때문에 확대하거나 축소해도 품질 저하가 없습니다.
- **성능**: 필요한 SVG만 불러오면 되므로, 불필요한 리소스 로딩을 줄일 수 있습니다.

#### **단점:**

- **관리 복잡성**: 많은 수의 아이콘을 관리해야 할 경우, 각각의 SVG 파일을 관리하고 로드하는 것이 다소 번거로울 수 있습니다.
- **브라우저 호환성**: 매우 오래된 브라우저에서는 SVG 지원이 완벽하지 않을 수 있으나, 대부분의 최신 브라우저에서는 잘 지원됩니다.

### 2. **웹폰트**

#### **장점:**

- **일관된 관리**: 수백 개의 아이콘을 하나의 폰트 파일로 관리할 수 있어 간단합니다. 한번 로드된 폰트는 다양한 곳에서 사용할 수 있습니다.
- **텍스트 기반 처리**: 아이콘을 글자처럼 다룰 수 있어 텍스트 스타일링 기능을 그대로 사용할 수 있습니다. 크기, 색상 등을 CSS로 쉽게 변경할 수 있습니다.
- **레거시 브라우저 지원**: 대부분의 브라우저에서 지원되며, 오래된 브라우저에서도 문제가 없습니다.

#### **단점:**

- **유연성 부족**: 개별 아이콘을 수정하거나 애니메이션을 추가하는 것이 어렵습니다. 또한, 여러 색상을 적용하는 것이 제한적입니다.
- **성능**: 모든 아이콘을 포함한 폰트를 로드해야 하기 때문에, 실제로 사용하지 않는 아이콘도 로드됩니다. 이는 성능에 영향을 미칠 수 있습니다.
- **접근성 문제**: 아이콘 폰트는 때때로 접근성 문제를 유발할 수 있습니다. 특히, 화면 리더기에서 아이콘을 올바르게 인식하지 못할 수 있습니다.

### **결론**

- **다양한 크기와 색상으로 개별 아이콘을 커스터마이징해야 하거나, 애니메이션을 적용하고 싶다면**: SVG 파일을 사용하는 것이 더 나은 선택입니다.
- **수많은 아이콘을 일관되게 관리하고, 텍스트 스타일링처럼 사용하고 싶다면**: 웹폰트가 유용할 수 있습니다.

물론입니다. `cmap` 테이블을 사용해 PUA(Private Use Area)의 특정 유니코드 값으로 매핑하는 과정은 폰트가 글리프(문자나 아이콘)를 올바르게 표시하도록 하기 위한 중요한 단계입니다. 이를 이해하려면 먼저 몇 가지 기본적인 폰트 구조와 동작 원리를 알아야 합니다.

### **1. `cmap` 테이블의 역할**

폰트 파일 내부에는 여러 개의 테이블이 존재하며, 이 중 **`cmap`(character map)** 테이블은 유니코드 코드 포인트와 글리프(폰트 파일 내에서 글자나 아이콘을 나타내는 실제 그림)를 매핑하는 정보를 담고 있습니다. `cmap` 테이블은 입력된 유니코드 값이 어떤 글리프를 나타내는지 알려주는 일종의 "지도" 역할을 합니다.

### **2. `cmap` 테이블의 구성**

`cmap` 테이블은 다음과 같은 방식으로 구성됩니다:

- **플랫폼 ID, 인코딩 ID**: 어떤 플랫폼(예: Windows, macOS 등)과 인코딩 방식(예: 유니코드)에서 사용할지를 정의합니다.
- **포맷**: 매핑 테이블의 포맷을 정의합니다. 폰트에서 가장 일반적인 것은 포맷 4입니다.
- **서브테이블**: 실제 매핑 정보를 담고 있는 테이블입니다. 이 서브테이블에서 유니코드 코드 포인트를 폰트의 글리프 인덱스(글리프가 폰트 내에서 위치한 위치)로 변환합니다.

### **3. `cmap` 테이블을 통한 PUA 매핑 과정**

1. **유니코드 코드 포인트 결정**: 개발자가 폰트에 포함된 아이콘을 사용하려고 할 때, Material Icons와 같은 폰트는 PUA 영역의 특정 유니코드 코드 포인트를 사용합니다. 예를 들어, "home"이라는 아이콘은 `U+E88A`에 매핑될 수 있습니다. 이 `U+E88A`는 PUA 영역의 코드 포인트입니다.

2. **글리프 인덱스와 매핑**: 폰트 파일이 로드되면, `cmap` 테이블은 입력된 코드 포인트(`U+E88A`)를 해당하는 글리프 인덱스로 변환합니다. 이 글리프 인덱스는 폰트 파일 내부에서 "home" 아이콘이 저장된 위치를 가리킵니다.

3. **아이콘 출력**: 브라우저는 `cmap` 테이블을 사용해 "home"이라는 텍스트가 `U+E88A`로 변환된 것을 감지하고, 이 코드 포인트에 매핑된 글리프를 찾아 화면에 렌더링합니다. 이렇게 하면 사용자가 "home"이라고 입력한 텍스트가 실제로는 해당 아이콘으로 화면에 나타납니다.

### **4. 예시**

다음은 이 과정을 단순화하여 보여주는 예시입니다:

- **폰트에 "home" 아이콘이 포함된 경우**:
  - "home" 텍스트 → 유니코드 PUA 값 `U+E88A`로 변환
  - `U+E88A`는 `cmap` 테이블에서 글리프 인덱스 `450`에 매핑됨
  - 글리프 인덱스 `450`에 있는 아이콘을 화면에 렌더링

즉, 개발자가 텍스트로 "home"을 입력하면, 폰트의 `cmap` 테이블이 이를 PUA 영역의 유니코드 코드 포인트로 변환하고, 해당 코드 포인트가 글리프 인덱스로 매핑되어 실제 아이콘이 출력됩니다.

### **5. `cmap` 테이블의 중요성**

`cmap` 테이블이 없다면, 폰트 시스템은 어떤 유니코드 코드 포인트가 어떤 글리프를 나타내야 하는지 알 수 없기 때문에 폰트가 제대로 작동하지 않습니다. 특히 PUA 영역의 코드 포인트는 표준 문자와 달리 특정한 의미가 정해져 있지 않기 때문에, `cmap` 테이블의 매핑이 매우 중요합니다.

### **결론**

Material Icons와 같은 아이콘 폰트는 `cmap` 테이블을 통해 텍스트로 입력된 문자열을 PUA 영역의 특정 유니코드 코드 포인트로 변환하고, 이 코드 포인트에 매핑된 글리프(아이콘)를 렌더링합니다. 이 과정 덕분에 사용자는 단순히 텍스트를 입력하는 것만으로 복잡한 아이콘을 쉽게 사용할 수 있게 됩니다.

SVG 파일을 CSS로 커스터마이징하는 방법은 다양합니다. SVG는 XML 기반의 벡터 이미지 형식이기 때문에, HTML 문서 내에서 스타일링하거나, 외부 CSS 파일을 사용하여 SVG의 색상, 크기, 애니메이션 등을 조정할 수 있습니다.

좋은 질문이에요! 구글 머티리얼 아이콘에서는 아이콘 이름(예: `"home"`, `"delete"`)이 실제 내부적으로 어떻게 특정 **유니코드 문자(Character)**에 매핑되는지 구체적으로 설명해드릴게요.

---

## 🔹 1. **웹 폰트의 동작 방식**

웹 폰트 방식의 머티리얼 아이콘은 기본적으로 **아이콘을 문자(Character)와 연결된 글꼴(Font)**로 제공합니다. 즉, 우리가 `"home"`이라고 입력하면 그것이 **폰트 내부의 특정 유니코드(Character code)**로 변환됩니다.

보통 웹 폰트의 경우에는 일반적인 문자(예: `a`, `A`, `숫자`, `특수문자`)를 표시하지만, 머티리얼 아이콘 폰트는 일반적인 텍스트가 아니라 **머티리얼 디자인 아이콘을 유니코드 문자에 매핑**하는 방식으로 동작합니다.

---

## 🔹 2. **아이콘 이름(human-readable label)과 유니코드 매핑**

구글은 "아이콘 이름"을 사람이 쉽게 읽을 수 있도록 정의했지만, 실제 폰트 내부에서는 아이콘 이름 자체를 렌더링하는 것이 아닙니다. 대신 해당하는 아이콘은 **특정 유니코드(Unicode) 값으로 매핑**됩니다.

예를 들어 `"home"` 아이콘이 내부적으로 매핑되는 유니코드 값은 `U+E88A`입니다.  
즉:

```html
<span class="material-symbols-outlined">home</span>
```

이 코드를 사용하면 내부적으로 `"home"` → `U+E88A` 문자로 변환되며,  
해당 문자 `U+E88A`가 **"Material Symbols Outlined" 폰트에서 정의된 glyph(글리프, 문자 이미지)**로 렌더링됩니다.

### ❓ 하지만 왜 우리가 직접 `&#xE88A;`라고 쓰지 않아도 될까요?

이는 **CSS 폰트의 `ligature`(합자) 기능** 때문입니다.

---

## 🔹 3. **CSS에서 `font-feature-settings: 'liga' 1;` (합자 사용)**

머티리얼 아이콘 폰트는 CSS에서 **합자(ligature) 기능**을 활성화하여 특정 문자열을 자동으로 유니코드 문자로 대체하는 방식으로 동작합니다.

머티리얼 아이콘의 CSS에는 기본적으로 아래 코드가 포함돼 있습니다.

```css
.material-symbols-outlined {
  font-family: 'Material Symbols Outlined';
  font-feature-settings: 'liga' 1; /* Ligature(합자) 설정 */
}
```

이 설정 덕분에 **특정한 글자를 입력하면 자동으로 해당하는 폰트 글리프(glyph)로 변환**됩니다.

즉, `"home"`을 입력하면:

1. `"home"` → `U+E88A` (자동 변환, CSS `liga` 옵션 때문)
2. `U+E88A` → **해당하는 아이콘 표시** (폰트 내부 매핑으로 인해)

이처럼 `"home"`은 내부적으로 **`U+E88A`로 변환된 후**, 아이콘을 나타내는 **폰트의 특정 글리프(이미지 문자)**로 출력됩니다.

⚡ **즉, `ligature` 기능이 있기 때문에 우리가 굳이 유니코드 값(`&#xE88A;`)을 직접 입력하지 않아도 "home"이라는 단어만 입력하면 자동 매핑되는 것입니다.**

---

## 🔹 4. **예제: 직접 유니코드 값 활용하기**

만약 직접 유니코드 값을 사용하고 싶다면, 아래처럼 아이콘의 유니코드를 HTML에서 직접 입력할 수 있습니다.

```html
<span class="material-symbols-outlined">&#xE88A;</span>
```

위 코드를 실행하면 `"home"`과 동일한 집 모양 아이콘이 표시됩니다.  
즉, `"home"` 대신 `&#xE88A;`를 입력해도 같은 결과를 얻을 수 있습니다.

하지만 구글은 이를 보다 사용하기 쉽게 **"home", "delete", "search"** 등의 가독성 높은 이름(human-readable name)으로 제공하고, CSS `ligature` 기능을 통해 자동 변환되도록 설계했습니다.

---

## 🔹 5. **머티리얼 아이콘과 유니코드 매핑 목록 확인 방법**

구글에서 제공하는 머티리얼 아이콘의 유니코드 매핑을 확인하려면:

1. [머티리얼 아이콘 공식 페이지](https://fonts.google.com/icons)에서 원하는 아이콘을 클릭합니다.
2. 아이콘 상세 정보(코드포인트, 유니코드 값 등)를 확인할 수 있습니다.

예를 들어:

- **`home`** → `Unicode: E88A`
- **`delete`** → `Unicode: E872`
- **`search`** → `Unicode: E8B6`

---

## 🎯 **정리**

- 우리가 `"home"`을 입력하면, CSS `ligature` 기능 덕분에 **자동으로 `U+E88A`로 변환**됨.
- `U+E88A`는 폰트 내에서 **"home" 아이콘에 해당하는 글리프(Glyph)**로 매핑됨.
- 덕분에 HTML에서 **직접 유니코드를 입력하지 않아도** `"home"`처럼 직관적인 아이콘 이름을 사용할 수 있음.
- 유니코드 값(예: `&#xE88A;`)을 직접 입력하면 동일한 아이콘이 나타나지만, **가독성 및 관리 편의성을 위해 문자열 기반의 대체 기능이 제공됨**.

---

### 🚀 **결론**

머티리얼 아이콘 시스템은 내부적으로 **폰트 글리프와 유니코드 값을 매핑하는 방식**으로 동작하며, CSS의 `ligature` 기능을 활용해 사람이 읽기 쉬운 `"home"`, `"search"` 등의 단어를 유니코드 문자로 자동 변환하는 기능을 제공합니다. 🎨✨
