---
folderName: web_vulnerabilities
updatedAt: 2024-08-14
title: 웹 취약점
tag: web, security
isPublished:
---

# 웹 취약점

- [CSRF](#csrf)
- [XSS](#xss)
- [Network Sniffing](#network-sniffing)

## CSRF

CSRF(Cross-Site Request Forgery, 크로스 사이트 요청 위조)는 웹 취약점의 하나로, 공격자가 사용자의 웹 브라우저를 이용해 원하지 않는 행동을 강제로 수행하게 하는 공격 기법이다. 이 공격은 사용자가 인증된 상태로 다른 웹사이트를 방문할 때 발생할 수 있으며, 이를 통해 공격자는 사용자의 권한으로 악의적인 요청을 서버에 보낼 수 있다.

CSRF 공격의 기본적인 흐름은 다음과 같다:

1. 사용자 인증: 사용자가 특정 웹사이트(예: 은행 사이트)에 로그인하여 인증된 세션을 유지하고 있다.
2. 악의적인 웹사이트 방문: 사용자가 동시에 다른 악의적인 웹사이트를 방문합니다.
3. 악의적인 요청: 악의적인 웹사이트가 사용자 대신 인증된 웹사이트에 요청을 보냅니다. 이 요청은 사용자의 세션 정보를 포함하고 있어, 서버는 이를 정당한 요청으로 처리할 수 있다.

예를 들어, 사용자가 은행 웹사이트에 로그인한 상태에서 악성 웹페이지를 방문하면, 악성 웹페이지가 사용자 계좌에서 자금을 이체하는 요청을 자동으로 보내는 것이다. 은행 서버는 이 요청이 합법적인 사용자에 의해 발생한 것으로 간주하여, 요청을 처리할 수 있다.

CSRF 방어 방법으로는 다음과 같은 것들이 있다:

- CSRF 토큰 사용: 각 요청에 대해 서버가 발급한 고유한 CSRF 토큰을 포함시켜, 요청이 서버에서 발급한 토큰과 일치하는지 검증합니다.
- 참조자 헤더 확인: 요청의 'Referer' 헤더를 확인하여, 요청이 신뢰할 수 있는 출처에서 발생했는지 검증합니다.
- 쿠키에 SameSite 속성 설정: 쿠키의 `SameSite` 속성을 설정하여, 제3의 웹사이트에서 발송한 요청에 쿠키가 포함되지 않도록 합니다.

CSRF는 사용자의 인증 상태를 악용하기 때문에, 사용자와 서버 간의 신뢰 관계를 위협할 수 있다. 따라서 CSRF 방어는 웹 애플리케이션 보안의 중요한 부분이다.

## XSS

XSS(Cross-Site Scripting, 크로스 사이트 스크립팅)는 웹 취약점의 하나로, 공격자가 웹 애플리케이션의 사용자 입력 필드에 악의적인 스크립트를 삽입하고, 이를 통해 사용자의 브라우저에서 악성 코드를 실행하도록 하는 공격 기법이다. XSS는 웹 페이지에 삽입된 스크립트가 다른 사용자의 브라우저에서 실행되는 것을 이용하여 다양한 공격을 수행할 수 있게 합니다.

XSS 공격의 기본적인 흐름은 다음과 같다:

1. 악성 스크립트 삽입: 공격자가 웹 애플리케이션의 입력 필드, URL 파라미터, 쿠키 등 여러 위치에 악의적인 JavaScript 코드를 삽입합니다.
2. 스크립트 실행: 삽입된 스크립트가 다른 사용자의 브라우저에서 실행됩니다.
3. 정보 탈취 또는 조작: 공격자는 사용자의 세션 쿠키를 탈취하거나, 사용자의 브라우저에서 악성 동작을 수행할 수 있다.

XSS는 크게 세 가지 유형으로 나눌 수 있다:

1. 반사형 XSS (Reflected XSS):

   - 공격자가 악성 스크립트를 포함한 URL을 생성하고, 이를 피해자가 클릭하도록 유도합니다. 스크립트는 서버에 의해 즉시 반사되어 사용자의 브라우저에서 실행됩니다.
   - 예를 들어, 검색 결과 페이지에서 검색어를 출력할 때, 검색어에 악성 스크립트가 포함되어 있을 경우 발생할 수 있다.

2. 저장형 XSS (Stored XSS):

   - 악성 스크립트가 서버에 저장되고, 이후 서버가 이 스크립트를 다른 사용자의 브라우저로 전달합니다. 이로 인해 저장된 스크립트가 다른 사용자의 브라우저에서 실행됩니다.
   - 예를 들어, 게시판이나 댓글 시스템에 악성 스크립트를 삽입하여, 다른 사용자들이 해당 게시물이나 댓글을 볼 때 스크립트가 실행됩니다.

3. DOM 기반 XSS (DOM-based XSS):
   - 클라이언트 측 스크립트가 악의적인 데이터를 DOM(Document Object Model)에서 처리하여 발생하는 취약점이다. 서버에서의 처리가 아닌, 브라우저에서의 DOM 조작에 의해 스크립트가 실행됩니다.
   - 예를 들어, URL 파라미터를 DOM에 직접 삽입하는 경우, 악성 스크립트가 실행될 수 있다.

XSS 방어 방법으로는 다음과 같은 것들이 있다:

- 출력 인코딩: 사용자 입력을 HTML, JavaScript, CSS 등에서 안전하게 출력하도록 인코딩합니다. 예를 들어, HTML 엔티티로 변환하여 특수 문자가 실행되지 않도록 합니다.
- 입력 검증: 사용자 입력을 서버 측에서 검증하고, 가능한 경우 입력 값의 범위를 제한합니다.
- 콘텐츠 보안 정책 (CSP): CSP를 설정하여 웹 페이지에서 실행될 수 있는 콘텐츠의 출처를 제한합니다. 이를 통해 악성 스크립트의 실행을 방지할 수 있다.
- 자바스크립트 라이브러리 사용: 신뢰할 수 있는 라이브러리를 사용하여, XSS에 대한 보호 기능을 제공하는 경우가 있다.

XSS는 사용자 브라우저에서 직접 악성 코드를 실행시킬 수 있기 때문에, 보안 위험을 초래할 수 있으며, 웹 애플리케이션 보안에서 중요한 부분이다.

## Network Sniffing

네트워크 스니핑(Network Sniffing) 공격은 네트워크를 통해 전송되는 데이터를 가로채어 분석하거나 조작하는 공격 기법이다. 네트워크 스니핑을 통해 공격자는 네트워크를 통해 전송되는 패킷을 실시간으로 모니터링하고, 민감한 정보를 획득하거나 악의적인 목적에 사용할 수 있다.

네트워크 스니핑 공격의 기본적인 흐름은 다음과 같다:

1. 패킷 캡처: 공격자는 네트워크에서 전송되는 데이터 패킷을 캡처합니다. 이를 위해 스니퍼라는 도구를 사용하거나, 네트워크의 중간에 위치하여 패킷을 가로채는 방식으로 수행할 수 있다.
2. 패킷 분석: 캡처한 패킷을 분석하여, 데이터의 내용, 사용자 인증 정보, 네트워크 트래픽 패턴 등을 파악합니다.
3. 정보 탈취: 민감한 정보를 추출하여, 이를 악의적인 용도로 사용할 수 있다. 예를 들어, 로그인 자격 증명, 개인 정보, 금융 거래 정보 등을 포함할 수 있다.

네트워크 스니핑의 주요 유형은 다음과 같다:

1. 패킷 스니핑 (Packet Sniffing):

   - 네트워크를 통해 전송되는 패킷을 캡처하고 분석하여, 패킷의 내용이나 메타데이터를 추출하는 방법이다.
   - 일반적으로 네트워크 스니퍼 도구(예: Wireshark, tcpdump 등)를 사용하여 수행됩니다.

2. 맨인더미들 공격 (Man-in-the-Middle, MITM):

   - 공격자가 두 통신 당사자 사이에 위치하여, 전송되는 데이터를 가로채고 수정하거나 재전송합니다.
   - 이를 통해 공격자는 양측의 통신 내용을 완전히 볼 수 있으며, 중간에서 데이터를 조작할 수도 있다.

3. ARP 스푸핑 (ARP Spoofing):
   - 공격자가 ARP(Address Resolution Protocol) 패킷을 조작하여, 네트워크에서 자신의 MAC 주소를 다른 IP 주소와 연결짓는 방법이다.
   - 이를 통해 네트워크 트래픽을 자신이 제어하는 장비로 전송하게 하고, 패킷을 가로채거나 변조할 수 있다.

네트워크 스니핑 방어 방법으로는 다음과 같은 것들이 있다:

- 암호화: 데이터 전송 시 암호화를 적용하여, 네트워크에서 가로챈 패킷이 읽히지 않도록 합니다. 예를 들어, HTTPS, TLS/SSL 등을 사용하여 데이터의 안전성을 보장합니다.
- 네트워크 보안 프로토콜 사용: VPN(Virtual Private Network)이나 IPsec과 같은 보안 프로토콜을 사용하여 네트워크 트래픽을 보호합니다.
- 네트워크 세분화 및 분리: 네트워크를 세분화하여 중요한 데이터가 있는 네트워크와 일반 네트워크를 분리하고, 보안 수준을 높이다.
- ARP 스푸핑 방어: ARP 스푸핑 공격을 방지하기 위해, ARP 스푸핑 방지 도구나 스위치에서의 정적 ARP 엔트리 설정을 사용할 수 있다.
- 네트워크 모니터링 및 경고 시스템: 네트워크 트래픽을 모니터링하고 비정상적인 활동을 감지하여, 공격 시도를 조기에 탐지하고 대응할 수 있다.

네트워크 스니핑은 네트워크 보안에서 중요한 취약점으로, 적절한 방어 조치를 통해 공격의 위험을 최소화하는 것이 중요합니다.

## 1

웹 보안에서 **XSS**(Cross-Site Scripting)와 **CSRF**(Cross-Site Request Forgery)는 매우 중요한 두 가지 공격 벡터로, 웹 서버의 구성 방식에 따라 그 위협이 달라질 수 있다. 여기서는 클라이언트와 같은 도메인을 사용하는 전통적인 웹 서버와 클라이언트와 분리되어 다른 도메인을 사용하는 API 서버의 관점에서 XSS와 CSRF 공격을 분석해 보겠다.

### 1. 클라이언트와 같은 도메인을 사용하는 전통적인 웹 서버

#### **XSS (Cross-Site Scripting)**

- **위협**: XSS는 공격자가 악성 스크립트를 웹 페이지에 삽입하여 사용자의 브라우저에서 실행되도록 유도하는 공격이다. 전통적인 웹 서버의 경우, 클라이언트와 같은 도메인을 공유하므로 스크립트가 실행될 때 해당 도메인의 모든 권한을 가질 수 있다. 이는 쿠키 접근, 세션 하이재킹, DOM 조작 등을 통해 사용자를 악의적으로 조작할 수 있는 위험을 동반한다.
- **예방**: XSS 방어를 위해서는 사용자 입력의 철저한 검증 및 인코딩, 콘텐츠 보안 정책(CSP) 설정 등을 적용해야 한다.

#### **CSRF (Cross-Site Request Forgery)**

- **위협**: CSRF는 사용자가 의도하지 않은 요청을 특정 웹 서버에 보낼 수 있도록 하는 공격이다. 동일 도메인을 사용하는 전통적인 웹 서버에서는, 사용자가 이미 로그인된 상태라면 CSRF 공격을 통해 악의적인 요청이 동일 세션과 권한으로 서버에 전달될 수 있다. 이는 사용자의 의지와 상관없이 데이터 변경이나 민감한 작업을 실행하는 등의 문제를 일으킬 수 있다.
- **예방**: CSRF 방어를 위해서는 서버 측에서 CSRF 토큰을 사용하거나, `SameSite` 속성을 가진 쿠키를 사용하는 방법 등이 있다.

### 2. 클라이언트와 분리되어 다른 도메인을 사용하는 API 서버

#### **XSS (Cross-Site Scripting)**

- **위협**: API 서버가 클라이언트와 다른 도메인을 사용할 경우, API 서버 자체에서 XSS 공격이 발생할 가능성은 낮아진다. 이는 API 서버가 주로 JSON과 같은 데이터 형식으로 응답을 보내고, HTML 콘텐츠를 직접 렌더링하지 않기 때문이다. 그러나 클라이언트 측 웹 애플리케이션에서 여전히 XSS 공격의 위험이 존재할 수 있다.
- **예방**: 클라이언트 측에서 데이터를 처리할 때 XSS 방어를 위한 입력 검증 및 출력을 인코딩하는 것이 중요하다. 또한, API 서버의 경우에는 응답에 포함된 데이터를 안전하게 처리하는 것이 필요하다.

#### **CSRF (Cross-Site Request Forgery)**

- **위협**: API 서버가 다른 도메인을 사용하는 경우, 기본적으로 CSRF 공격에 대한 위험이 줄어든다. 이는 브라우저가 다른 도메인 간의 요청에 대해 `CORS`(Cross-Origin Resource Sharing) 정책을 따르기 때문이다. 즉, CSRF 공격을 통해 클라이언트에서 API 서버로 요청을 보내는 것이 어렵다.
- **예방**: API 서버에서 `CORS` 정책을 제대로 설정하여 허용된 도메인에서만 요청을 받도록 설정하는 것이 중요하다. 또한, 인증 방식으로 토큰 기반 인증(JWT 등)을 사용하면 CSRF 공격에 대한 추가적인 보호를 제공할 수 있다.

### **결론**

클라이언트와 같은 도메인을 사용하는 전통적인 웹 서버는 XSS와 CSRF 공격에 더 취약할 수 있으며, 이를 방어하기 위한 조치가 필수적이다. 반면에, 클라이언트와 다른 도메인을 사용하는 API 서버는 기본적으로 CSRF에 대한 저항력이 높으며, XSS 공격에 대한 위험도 상대적으로 낮지만 여전히 방어책을 마련해야 한다. 각 서버 구조에 따라 적절한 보안 조치를 취하는 것이 중요하다.

##

현대의 모던 웹에서는 다양한 기술과 보안 기법이 발전하면서 **XSS**(Cross-Site Scripting)와 **CSRF**(Cross-Site Request Forgery)에 대한 대응이 많이 개선되었다. 그러나 완벽하게 제거된 것은 아니며, 여전히 주의가 필요하다. 각각의 위협에 대해 현대 웹 기술이 어떻게 대응하고 있는지 설명하겠다.

### 1. XSS (Cross-Site Scripting)

#### **현대 웹에서의 대처 방법**

- **프레임워크 보안 기능**: React, Angular, Vue.js와 같은 현대의 프론트엔드 프레임워크는 기본적으로 XSS 공격을 방어하기 위한 보안 기능을 제공한다. 예를 들어, React는 JSX 템플릿에서 HTML 태그나 속성 내에서 사용자의 입력을 자동으로 이스케이프(escape) 처리한다.
- **Content Security Policy (CSP)**: CSP는 브라우저가 신뢰할 수 있는 소스에서만 리소스를 로드하도록 강제하는 보안 정책이다. 이를 통해 악성 스크립트의 실행을 방지할 수 있다. CSP는 XSS를 효과적으로 방어할 수 있는 방법 중 하나로 점점 더 많이 사용되고 있다.
- **정적 분석 도구**: 현대 웹 개발에서는 정적 분석 도구(SAST)를 사용하여 코드에 잠재된 XSS 취약점을 사전에 발견하고 수정할 수 있다.

#### **완화된 위험**

이러한 기술 덕분에 XSS 공격의 위험은 크게 줄어들었다. 하지만, 여전히 개발자가 직접 스크립트를 삽입하거나 사용자 입력을 적절하게 검증하지 않는 경우 XSS 공격이 발생할 수 있다. 따라서 개발자의 주의와 적절한 보안 설정이 중요하다.

### 2. CSRF (Cross-Site Request Forgery)

#### **현대 웹에서의 대처 방법**

- **SameSite 쿠키 속성**: 최근 브라우저들은 `SameSite` 쿠키 속성을 지원하여, 쿠키가 외부 사이트에서의 요청에 사용되지 않도록 제어할 수 있다. 이는 CSRF 공격을 방어하는 데 매우 효과적이다.
  - `SameSite=Lax`: 대부분의 상황에서 CSRF 방어에 충분하며, GET 요청에 대해서는 쿠키가 전달되지 않게 한다.
  - `SameSite=Strict`: 완전한 방어를 제공하며, 외부 사이트에서의 모든 요청에 대해 쿠키가 전송되지 않는다.
- **토큰 기반 인증**: 현대 웹 애플리케이션에서는 JWT(JSON Web Token)와 같은 토큰 기반 인증 방식을 많이 사용한다. 이 방식은 CSRF에 더 안전하며, 서버는 각 요청에서 토큰을 검증함으로써 사용자의 요청이 신뢰할 수 있는지 확인한다.
- **CORS (Cross-Origin Resource Sharing)**: API 서버와 같은 경우, CORS 정책을 사용해 허용된 도메인에서만 요청을 받을 수 있도록 설정함으로써 CSRF 공격을 방지할 수 있다.

#### **완화된 위험**

`SameSite` 속성의 사용이 보편화되고 토큰 기반 인증이 널리 퍼지면서 CSRF 공격의 위험은 과거에 비해 크게 줄어들었다. 그러나, 여전히 안전하지 않게 설정된 쿠키나 취약한 백엔드 로직이 있을 경우 CSRF 공격이 가능하다. 따라서 올바른 설정이 필요하다.

### **결론**

모던 웹에서는 XSS와 CSRF에 대한 보안 기술이 크게 발전하여 이들 공격에 대한 대응이 훨씬 강력해졌다. 프레임워크, 브라우저의 보안 기능, 그리고 최신 인증 방식의 도입 덕분에 전반적인 보안 수준이 높아졌으나, 여전히 개발자와 보안 담당자들의 주의가 필요하다. 기본 보안 원칙을 준수하고, 최신 기술을 적절히 활용함으로써 XSS와 CSRF 위험을 더욱 줄일 수 있다.

XSS와 CSRF의 차이는 단순히 스크립트를 실행하느냐, 혹은 `img`나 `form` 태그를 통해 요청을 보내느냐의 차이에 그치지 않습니다. 두 공격의 차이는 **공격의 본질과 목적**에서 비롯됩니다. 자세히 설명하면 다음과 같습니다.

### 1. **공격의 본질적인 차이**

- **XSS (Cross-Site Scripting)**

  - **본질**: XSS는 공격자가 악의적인 스크립트를 웹사이트에 삽입하여, 해당 스크립트가 사용자(피해자)의 브라우저에서 실행되도록 하는 공격입니다.
  - **목적**: 이 공격의 목적은 사용자의 민감한 정보(예: 쿠키, 세션 토큰, 비밀번호 등)를 탈취하거나, 웹 페이지의 내용을 조작하여 사용자에게 피해를 주는 것입니다.
  - **공격 방법**: XSS에서는 `<script>` 태그와 같은 스크립트를 사용하거나, 속성 내에 자바스크립트를 포함시켜 공격을 실행합니다. 여기에는 악성 스크립트를 직접 실행시키는 것뿐만 아니라, 예를 들어 `onload` 또는 `onclick`과 같은 이벤트 핸들러에 자바스크립트를 주입하는 방법도 포함됩니다.

- **CSRF (Cross-Site Request Forgery)**
  - **본질**: CSRF는 공격자가 사용자의 인증된 세션을 악용하여 사용자가 의도하지 않은 요청을 신뢰하는 웹사이트에 보내도록 유도하는 공격입니다.
  - **목적**: 이 공격의 목적은 사용자의 권한으로 중요한 작업(예: 돈 이체, 계정 정보 변경 등)을 수행하는 것입니다. 공격자는 사용자가 이미 로그인되어 있다는 것을 악용합니다.
  - **공격 방법**: CSRF에서는 보통 `img`, `form`, `a` 태그 등을 사용하여 자동으로 서버에 요청을 보냅니다. 자바스크립트 없이도 단순히 HTML 요소를 사용하여 사용자가 특정 URL로 요청을 보내도록 유도할 수 있습니다.

### 2. **스크립트 실행 여부 vs. 자동 요청**

- **XSS**: 스크립트 실행이 핵심입니다. 악성 자바스크립트가 사용자의 브라우저에서 실행되며, 이로 인해 다양한 악성 행위를 수행할 수 있습니다. 예를 들어, 자바스크립트가 쿠키 정보를 탈취하여 외부 서버로 전송하는 경우입니다.
- **CSRF**: 사용자가 의도하지 않은 요청을 자동으로 수행하는 것이 핵심입니다. 여기에 스크립트가 직접 사용될 수도 있지만, 대부분의 경우 스크립트 없이도 공격이 가능합니다. 예를 들어, 공격자는 사용자를 속여 특정 `img` 태그를 로드하게 하거나, 자동으로 제출되는 `form`을 사용하여 특정 작업을 실행하게 할 수 있습니다.

### 3. **보호 방법**

- **XSS 방어**:

  - 사용자 입력값을 철저히 검증하고 필터링합니다.
  - 출력을 할 때는 이스케이핑(escaping)을 통해 스크립트 실행을 방지합니다.
  - `Content Security Policy (CSP)`를 설정하여 악성 스크립트가 실행되지 않도록 제한합니다.

- **CSRF 방어**:
  - **CSRF 토큰**을 사용하여 서버가 요청이 신뢰할 수 있는 출처에서 왔는지 확인합니다.
  - **SameSite 쿠키 속성**을 설정하여 크로스 사이트 요청 시 쿠키가 전송되지 않도록 합니다.
  - 중요한 작업에는 추가적인 인증(예: 비밀번호 입력)을 요구합니다.

### 요약

- **XSS**: 악성 스크립트를 사용하여 사용자의 브라우저에서 직접 실행하는 공격입니다. 주로 사용자의 민감한 정보를 탈취하거나 페이지를 조작하는 데 사용됩니다.
- **CSRF**: 사용자가 인지하지 못한 상태에서 인증된 세션을 이용해 서버에 요청을 보내는 공격입니다. 주로 사용자의 권한으로 서버에서 중요한 작업을 수행하는 데 사용됩니다.

따라서, XSS와 CSRF의 차이는 단순히 "스크립트를 실행하느냐"와 "태그를 통해 요청을 보내느냐"에 그치는 것이 아니라, **공격자가 목표로 하는 것과 공격 방법에서의 근본적인 차이**에 있습니다.
