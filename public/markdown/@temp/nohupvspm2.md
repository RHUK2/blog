- [1. `nohup` (No Hangup)](#1-nohup-no-hangup)
  - [사용 예:](#사용-예)
- [2. PM2 (Process Manager 2)](#2-pm2-process-manager-2)
  - [사용 예:](#사용-예-1)
- [비교 요약](#비교-요약)
- [결론](#결론)
  - [1. 백그라운드 프로세스 (Background Process)](#1-백그라운드-프로세스-background-process)
  - [2. 데몬 프로세스 (Daemon Process)](#2-데몬-프로세스-daemon-process)
  - [3. 핵심 차이점](#3-핵심-차이점)
  - [4. 유사점](#4-유사점)
  - [예를 들어:](#예를-들어)

PM2와 `nohup`는 둘 다 백그라운드에서 애플리케이션(주로 서버 애플리케이션 또는 스크립트)을 실행하는 데 유용한 도구입니다. 그러나 그 작동 방식과 기능에는 큰 차이가 있습니다. 다음은 백그라운드 프로세스 예제를 통해 두 도구의 차이점을 설명합니다.

---

## 1. `nohup` (No Hangup)

- `nohup`는 터미널 세션이 종료되어도 프로세스를 계속 실행하도록 보장하는 유닉스 명령어입니다.
- 출력(stdout/stderr)을 기본적으로 로그 파일(`nohup.out`)로 리다이렉트합니다.
- 간단하고 시스템 리소스를 거의 소모하지 않으며, 별도의 데몬이나 관리자는 없습니다.

### 사용 예:

간단한 Node.js 앱을 백그라운드로 실행한다고 가정.

```sh
nohup node app.js &
```

- `nohup`은 `node app.js`를 터미널 세션 종료(또는 로그아웃) 후에도 계속 실행합니다.
- 출력은 `nohup.out` 파일에 기록됩니다.
- 실행 중인 프로세스를 중지하려면 프로세스 ID(PID)를 찾아 수동으로 종료해야 합니다. 예를 들어:
  ```sh
  ps aux | grep node
  kill -9 <PID>
  ```
- 프로세스 관리, 모니터링, 로그 관리는 매우 제한적입니다.

---

## 2. PM2 (Process Manager 2)

- PM2는 Node.js 애플리케이션 관리에 특화된 더 발전된 프로세스 관리 도구입니다.
- 애플리케이션 재시작, 로드 밸런싱, 로그 관리, 상태 모니터링 등의 고급 기능을 제공합니다.
- 백그라운드에서 `데몬`으로 실행되어 여러 프로세스를 중앙에서 관리할 수 있습니다.
- 터미널이나 시스템이 종료되더라도 앱을 유지하며, 시스템 재부팅 시 자동 시작 구성이 가능합니다.

### 사용 예:

같은 Node.js 앱을 PM2를 사용해 실행.

```sh
pm2 start app.js --name my-app
```

- PM2는 백그라운드에서 `app.js`를 실행하며, 실행 상태를 추적합니다.
- 동일한 이름(`my-app`)을 통해 프로세스를 관리, 제어할 수 있습니다.
- 다양한 명령어를 사용해 앱을 쉽게 관리할 수 있습니다:
  ```sh
  pm2 list         # 실행 중인 앱 목록 확인
  pm2 restart my-app  # 앱 재시작
  pm2 stop my-app     # 앱 정지
  pm2 logs my-app     # 실시간 로그 확인
  pm2 delete my-app   # 앱 종료 및 삭제
  ```
- 시스템 부팅 시 자동 시작 설정:
  ```sh
  pm2 startup
  pm2 save
  ```
- PM2는 로그 파일도 깔끔하게 관리합니다(`/~/.pm2/logs` 디렉토리).

---

## 비교 요약

| 기능/특징             | `nohup`                                          | PM2                                                   |
| --------------------- | ------------------------------------------------ | ----------------------------------------------------- |
| 기본 목적             | 간단히 백그라운드에서 앱 실행                    | 애플리케이션 프로세스 관리 및 모니터링                |
| 프로세스 재시작       | 불가능 (프로세스 중단 시 수동으로 재실행해야 함) | 가능 (자동 재시작, 크래시 복구)                       |
| 로그 관리             | 출력 로그를 기본적으로 `nohup.out`에 저장        | 로그 파일 관리/분리/모니터링 기능                     |
| 프로세스 모니터링     | 없음 (수동으로 `ps` 명령어 사용)                 | `pm2 list`, `pm2 status` 등의 명령으로 상태 확인 가능 |
| 시스템 재부팅 후 유지 | 불가능 (재부팅 시 수동으로 실행 필요)            | 가능 (`pm2 startup` 설정 이용)                        |
| 리소스 활용           | 매우 적음                                        | PM2 자체 데몬이 동작하므로 약간의 추가 리소스 사용    |
| 기타 기능             | 없음                                             | 로드 밸런싱, 클러스터링, 로그 순환 등 고급 기능 제공  |

---

## 결론

- `nohup`은 간단한 단일 프로세스를 한 번 실행한 후 장기적으로 터미널을 떠나도 작동하게 하려는 경우에 적합합니다.
- PM2는 Node.js 애플리케이션이나, 복잡한 지속 실행 프로세스를 효율적으로 관리하고 모니터링하고자 할 때 적합합니다. 특히, 시스템 재부팅 후에도 애플리케이션을 지속적으로 동작하도록 요구되는 경우에는 PM2가 더 나은 선택지입니다.

백그라운드 프로세스와 데몬 프로세스는 컴퓨터 과학에서 프로세스 관리를 다룰 때 흔히 언급되는 개념이지만, 각각의 목적과 동작 방식에 차이가 있습니다. 이를 구별하기 위해 각 개념을 상세히 설명하겠습니다.

---

### 1. 백그라운드 프로세스 (Background Process)

- 정의

  - 백그라운드 프로세스는 사용자가 직접적으로 인터랙션하지 않는 상태로 실행되는 프로세스입니다. 일반적으로 사용자 프로세스일 수 있으며, 터미널이나 GUI와 같은 사용자의 환경에서 실행되지만 화면에 표시되지 않고 '백그라운드'에서 동작합니다.

- 특징
  - 명령을 실행한 터미널이나 세션과 연결되어 있습니다.
  - 터미널에서 명령을 입력할 때, 이를 백그라운드로 실행하기 위해 명령어 끝에 `&`를 붙이는 경우가 많습니다.
    예: `python my_script.py &`
  - 백그라운드로 실행되지만, 제어(입출력 등)가 여전히 실행한 터미널에 종속되어 있습니다.
  - 터미널이 닫히면 연결된 백그라운드 프로세스도 종료됩니다(예외: 특정 방법으로 터미널과 연결을 끊는 경우).
- 일반적인 사용 사례
  - 사용자가 필요로 하는 특정 작업을 실행하면서, 터미널을 즉각 사용할 수 있도록 하기 위한 용도.
  - 예를 들어, 데이터 처리 스크립트, 모니터링 등.

---

### 2. 데몬 프로세스 (Daemon Process)

- 정의

  - 데몬 프로세스는 시스템에서 백그라운드로 실행되며, 특정 서비스를 지속적으로 제공하기 위해 동작하는 독립적인 프로세스입니다. 주로 운영 체제나 사용자에게 지원적인 기능을 제공합니다.

- 특징

  - 시작 시 부모 프로세스(Terminal 등)와 완전히 분리되며 독립적으로 동작합니다.
  - 터미널 세션과 아무런 관계가 없으므로, 터미널이 종료되더라도 계속 실행됩니다.
  - 일반적으로 시스템 서비스와 관련된 작업을 수행합니다.
    예: 웹 서버(Apache, Nginx), 데이터베이스 서버(MySQL, PostgreSQL), 크론 데몬(cron), SSHD 등.
  - 전통적으로 데몬의 이름은 보통 접미사로 `d`가 붙습니다.
    예: `httpd` (웹 서버), `sshd` (SSH), `crond` (작업 스케줄러 데몬).
  - 데몬 프로세스는 보통 시스템의 시스템 초기화 단계에서 시작되며, 시스템이 중단될 때 종료됩니다.

- 데몬 프로세스 생성 과정

  1. 부모 프로세스가 `fork()`를 통해 자식 프로세스를 생성.
  2. 자식 프로세스는 `setsid()` 호출을 통해 새로운 세션과 프로세스 그룹의 리더가 됨 (터미널과의 연결을 끊음).
  3. 현재 작업 디렉토리를 루트 디렉토리로 변경하거나 특정 디렉토리로 이동 (`chdir("/")`), 파일 디스크립터를 닫음.
  4. 새로운 표준 입출력(파일, 로그 등)을 연결하여 독립 프로세스를 만듦.

- 일반적인 사용 사례
  - 서버, 스케줄러, 네트워크 서비스 제공자, 시스템 모니터링.

---

### 3. 핵심 차이점

| 구분            | 백그라운드 프로세스                              | 데몬 프로세스                                                     |
| --------------- | ------------------------------------------------ | ----------------------------------------------------------------- |
| 동작 방식       | 부모 프로세스 (터미널 등)와 연결된 상태에서 동작 | 부모 프로세스와 독립적으로 동작하며 터미널과의 연결이 완전히 끊김 |
| 시작            | 사용자 명령에 의해 직접적으로 시작됨             | 시스템 부팅 시 자동 시작되거나 특정 서비스가 필요할 때 시작됨     |
| 종료 조건       | 터미널/세션 종료 시 일반적으로 종료됨            | 시스템 종료 시까지 지속되거나 명시적으로 종료될 때만 종료됨       |
| 목적            | 배치 작업, 스크립트 실행 등                      | 지속적인 서비스 제공 (서버, 네트워크 서비스)                      |
| 파일 디스크립터 | 열려 있을 가능성이 높음                          | 일반적으로 모든 파일 디스크립터를 닫아 독립성을 유지              |

---

### 4. 유사점

- 둘 다 시스템에서 '백그라운드'에서 동작하는 것처럼 보이며, 사용자 인터페이스(UI)와 직접적으로 연관되지 않습니다.

---

### 예를 들어:

- 백그라운드 프로세스: 터미널에서 계산 스크립트를 실행(`python my_script.py &`)하면서 다른 작업을 계속하기 위해 사용함.
- 데몬 프로세스: 웹 서버(Apache), 크론 작업 스케줄러(cron)처럼 장기 실행되는 시스템 서비스를 제공.

---

요약하면, 모든 데몬은 백그라운드에서 실행되지만, 모든 백그라운드 프로세스가 데몬 프로세스는 아닙니다. 데몬은 백그라운드에서 독립적으로 동작하는 시스템 서비스로 설계된 반면, 일반적인 백그라운드 프로세스는 사용자가 특정 작업을 비동기로 처리하기 위해 터미널을 통해 실행하는 경우입니다.
