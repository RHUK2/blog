---
fileName: 임시
updatedAt: 2024-07-10
title: 임시
tag: temp
isPublished: false
---

웹 보안에서 **XSS**(Cross-Site Scripting)와 **CSRF**(Cross-Site Request Forgery)는 매우 중요한 두 가지 공격 벡터로, 웹 서버의 구성 방식에 따라 그 위협이 달라질 수 있다. 여기서는 클라이언트와 같은 도메인을 사용하는 전통적인 웹 서버와 클라이언트와 분리되어 다른 도메인을 사용하는 API 서버의 관점에서 XSS와 CSRF 공격을 분석해 보겠다.

### 1. 클라이언트와 같은 도메인을 사용하는 전통적인 웹 서버

#### **XSS (Cross-Site Scripting)**

- **위협**: XSS는 공격자가 악성 스크립트를 웹 페이지에 삽입하여 사용자의 브라우저에서 실행되도록 유도하는 공격이다. 전통적인 웹 서버의 경우, 클라이언트와 같은 도메인을 공유하므로 스크립트가 실행될 때 해당 도메인의 모든 권한을 가질 수 있다. 이는 쿠키 접근, 세션 하이재킹, DOM 조작 등을 통해 사용자를 악의적으로 조작할 수 있는 위험을 동반한다.
- **예방**: XSS 방어를 위해서는 사용자 입력의 철저한 검증 및 인코딩, 콘텐츠 보안 정책(CSP) 설정 등을 적용해야 한다.

#### **CSRF (Cross-Site Request Forgery)**

- **위협**: CSRF는 사용자가 의도하지 않은 요청을 특정 웹 서버에 보낼 수 있도록 하는 공격이다. 동일 도메인을 사용하는 전통적인 웹 서버에서는, 사용자가 이미 로그인된 상태라면 CSRF 공격을 통해 악의적인 요청이 동일 세션과 권한으로 서버에 전달될 수 있다. 이는 사용자의 의지와 상관없이 데이터 변경이나 민감한 작업을 실행하는 등의 문제를 일으킬 수 있다.
- **예방**: CSRF 방어를 위해서는 서버 측에서 CSRF 토큰을 사용하거나, `SameSite` 속성을 가진 쿠키를 사용하는 방법 등이 있다.

### 2. 클라이언트와 분리되어 다른 도메인을 사용하는 API 서버

#### **XSS (Cross-Site Scripting)**

- **위협**: API 서버가 클라이언트와 다른 도메인을 사용할 경우, API 서버 자체에서 XSS 공격이 발생할 가능성은 낮아진다. 이는 API 서버가 주로 JSON과 같은 데이터 형식으로 응답을 보내고, HTML 콘텐츠를 직접 렌더링하지 않기 때문이다. 그러나 클라이언트 측 웹 애플리케이션에서 여전히 XSS 공격의 위험이 존재할 수 있다.
- **예방**: 클라이언트 측에서 데이터를 처리할 때 XSS 방어를 위한 입력 검증 및 출력을 인코딩하는 것이 중요하다. 또한, API 서버의 경우에는 응답에 포함된 데이터를 안전하게 처리하는 것이 필요하다.

#### **CSRF (Cross-Site Request Forgery)**

- **위협**: API 서버가 다른 도메인을 사용하는 경우, 기본적으로 CSRF 공격에 대한 위험이 줄어든다. 이는 브라우저가 다른 도메인 간의 요청에 대해 `CORS`(Cross-Origin Resource Sharing) 정책을 따르기 때문이다. 즉, CSRF 공격을 통해 클라이언트에서 API 서버로 요청을 보내는 것이 어렵다.
- **예방**: API 서버에서 `CORS` 정책을 제대로 설정하여 허용된 도메인에서만 요청을 받도록 설정하는 것이 중요하다. 또한, 인증 방식으로 토큰 기반 인증(JWT 등)을 사용하면 CSRF 공격에 대한 추가적인 보호를 제공할 수 있다.

### **결론**

클라이언트와 같은 도메인을 사용하는 전통적인 웹 서버는 XSS와 CSRF 공격에 더 취약할 수 있으며, 이를 방어하기 위한 조치가 필수적이다. 반면에, 클라이언트와 다른 도메인을 사용하는 API 서버는 기본적으로 CSRF에 대한 저항력이 높으며, XSS 공격에 대한 위험도 상대적으로 낮지만 여전히 방어책을 마련해야 한다. 각 서버 구조에 따라 적절한 보안 조치를 취하는 것이 중요하다.

현대의 모던 웹에서는 다양한 기술과 보안 기법이 발전하면서 **XSS**(Cross-Site Scripting)와 **CSRF**(Cross-Site Request Forgery)에 대한 대응이 많이 개선되었다. 그러나 완벽하게 제거된 것은 아니며, 여전히 주의가 필요하다. 각각의 위협에 대해 현대 웹 기술이 어떻게 대응하고 있는지 설명하겠다.

### 1. XSS (Cross-Site Scripting)

#### **현대 웹에서의 대처 방법**

- **프레임워크 보안 기능**: React, Angular, Vue.js와 같은 현대의 프론트엔드 프레임워크는 기본적으로 XSS 공격을 방어하기 위한 보안 기능을 제공한다. 예를 들어, React는 JSX 템플릿에서 HTML 태그나 속성 내에서 사용자의 입력을 자동으로 이스케이프(escape) 처리한다.
- **Content Security Policy (CSP)**: CSP는 브라우저가 신뢰할 수 있는 소스에서만 리소스를 로드하도록 강제하는 보안 정책이다. 이를 통해 악성 스크립트의 실행을 방지할 수 있다. CSP는 XSS를 효과적으로 방어할 수 있는 방법 중 하나로 점점 더 많이 사용되고 있다.
- **정적 분석 도구**: 현대 웹 개발에서는 정적 분석 도구(SAST)를 사용하여 코드에 잠재된 XSS 취약점을 사전에 발견하고 수정할 수 있다.

#### **완화된 위험**

이러한 기술 덕분에 XSS 공격의 위험은 크게 줄어들었다. 하지만, 여전히 개발자가 직접 스크립트를 삽입하거나 사용자 입력을 적절하게 검증하지 않는 경우 XSS 공격이 발생할 수 있다. 따라서 개발자의 주의와 적절한 보안 설정이 중요하다.

### 2. CSRF (Cross-Site Request Forgery)

#### **현대 웹에서의 대처 방법**

- **SameSite 쿠키 속성**: 최근 브라우저들은 `SameSite` 쿠키 속성을 지원하여, 쿠키가 외부 사이트에서의 요청에 사용되지 않도록 제어할 수 있다. 이는 CSRF 공격을 방어하는 데 매우 효과적이다.
  - `SameSite=Lax`: 대부분의 상황에서 CSRF 방어에 충분하며, GET 요청에 대해서는 쿠키가 전달되지 않게 한다.
  - `SameSite=Strict`: 완전한 방어를 제공하며, 외부 사이트에서의 모든 요청에 대해 쿠키가 전송되지 않는다.
- **토큰 기반 인증**: 현대 웹 애플리케이션에서는 JWT(JSON Web Token)와 같은 토큰 기반 인증 방식을 많이 사용한다. 이 방식은 CSRF에 더 안전하며, 서버는 각 요청에서 토큰을 검증함으로써 사용자의 요청이 신뢰할 수 있는지 확인한다.
- **CORS (Cross-Origin Resource Sharing)**: API 서버와 같은 경우, CORS 정책을 사용해 허용된 도메인에서만 요청을 받을 수 있도록 설정함으로써 CSRF 공격을 방지할 수 있다.

#### **완화된 위험**

`SameSite` 속성의 사용이 보편화되고 토큰 기반 인증이 널리 퍼지면서 CSRF 공격의 위험은 과거에 비해 크게 줄어들었다. 그러나, 여전히 안전하지 않게 설정된 쿠키나 취약한 백엔드 로직이 있을 경우 CSRF 공격이 가능하다. 따라서 올바른 설정이 필요하다.

### **결론**

모던 웹에서는 XSS와 CSRF에 대한 보안 기술이 크게 발전하여 이들 공격에 대한 대응이 훨씬 강력해졌다. 프레임워크, 브라우저의 보안 기능, 그리고 최신 인증 방식의 도입 덕분에 전반적인 보안 수준이 높아졌으나, 여전히 개발자와 보안 담당자들의 주의가 필요하다. 기본 보안 원칙을 준수하고, 최신 기술을 적절히 활용함으로써 XSS와 CSRF 위험을 더욱 줄일 수 있다.

XSS와 CSRF의 차이는 단순히 스크립트를 실행하느냐, 혹은 `img`나 `form` 태그를 통해 요청을 보내느냐의 차이에 그치지 않습니다. 두 공격의 차이는 **공격의 본질과 목적**에서 비롯됩니다. 자세히 설명하면 다음과 같습니다.

### 1. **공격의 본질적인 차이**

- **XSS (Cross-Site Scripting)**

  - **본질**: XSS는 공격자가 악의적인 스크립트를 웹사이트에 삽입하여, 해당 스크립트가 사용자(피해자)의 브라우저에서 실행되도록 하는 공격입니다.
  - **목적**: 이 공격의 목적은 사용자의 민감한 정보(예: 쿠키, 세션 토큰, 비밀번호 등)를 탈취하거나, 웹 페이지의 내용을 조작하여 사용자에게 피해를 주는 것입니다.
  - **공격 방법**: XSS에서는 `<script>` 태그와 같은 스크립트를 사용하거나, 속성 내에 자바스크립트를 포함시켜 공격을 실행합니다. 여기에는 악성 스크립트를 직접 실행시키는 것뿐만 아니라, 예를 들어 `onload` 또는 `onclick`과 같은 이벤트 핸들러에 자바스크립트를 주입하는 방법도 포함됩니다.

- **CSRF (Cross-Site Request Forgery)**
  - **본질**: CSRF는 공격자가 사용자의 인증된 세션을 악용하여 사용자가 의도하지 않은 요청을 신뢰하는 웹사이트에 보내도록 유도하는 공격입니다.
  - **목적**: 이 공격의 목적은 사용자의 권한으로 중요한 작업(예: 돈 이체, 계정 정보 변경 등)을 수행하는 것입니다. 공격자는 사용자가 이미 로그인되어 있다는 것을 악용합니다.
  - **공격 방법**: CSRF에서는 보통 `img`, `form`, `a` 태그 등을 사용하여 자동으로 서버에 요청을 보냅니다. 자바스크립트 없이도 단순히 HTML 요소를 사용하여 사용자가 특정 URL로 요청을 보내도록 유도할 수 있습니다.

### 2. **스크립트 실행 여부 vs. 자동 요청**

- **XSS**: 스크립트 실행이 핵심입니다. 악성 자바스크립트가 사용자의 브라우저에서 실행되며, 이로 인해 다양한 악성 행위를 수행할 수 있습니다. 예를 들어, 자바스크립트가 쿠키 정보를 탈취하여 외부 서버로 전송하는 경우입니다.
- **CSRF**: 사용자가 의도하지 않은 요청을 자동으로 수행하는 것이 핵심입니다. 여기에 스크립트가 직접 사용될 수도 있지만, 대부분의 경우 스크립트 없이도 공격이 가능합니다. 예를 들어, 공격자는 사용자를 속여 특정 `img` 태그를 로드하게 하거나, 자동으로 제출되는 `form`을 사용하여 특정 작업을 실행하게 할 수 있습니다.

### 3. **보호 방법**

- **XSS 방어**:

  - 사용자 입력값을 철저히 검증하고 필터링합니다.
  - 출력을 할 때는 이스케이핑(escaping)을 통해 스크립트 실행을 방지합니다.
  - `Content Security Policy (CSP)`를 설정하여 악성 스크립트가 실행되지 않도록 제한합니다.

- **CSRF 방어**:
  - **CSRF 토큰**을 사용하여 서버가 요청이 신뢰할 수 있는 출처에서 왔는지 확인합니다.
  - **SameSite 쿠키 속성**을 설정하여 크로스 사이트 요청 시 쿠키가 전송되지 않도록 합니다.
  - 중요한 작업에는 추가적인 인증(예: 비밀번호 입력)을 요구합니다.

### 요약

- **XSS**: 악성 스크립트를 사용하여 사용자의 브라우저에서 직접 실행하는 공격입니다. 주로 사용자의 민감한 정보를 탈취하거나 페이지를 조작하는 데 사용됩니다.
- **CSRF**: 사용자가 인지하지 못한 상태에서 인증된 세션을 이용해 서버에 요청을 보내는 공격입니다. 주로 사용자의 권한으로 서버에서 중요한 작업을 수행하는 데 사용됩니다.

따라서, XSS와 CSRF의 차이는 단순히 "스크립트를 실행하느냐"와 "태그를 통해 요청을 보내느냐"에 그치는 것이 아니라, **공격자가 목표로 하는 것과 공격 방법에서의 근본적인 차이**에 있습니다.
