---
folderName: browser_routing
updatedAt: 2025-01-02
title: 브라우저 라우팅
tag: browser
isPublished: true
---

기존 라우팅과 클라이언트 사이드 라우팅은 웹 애플리케이션에서 페이지 전환을 처리하는 두 가지 주요 방식입니다. 이 두 접근 방식은 서로 다른 방식으로 페이지 요청을 처리하며, 각각의 장단점이 있습니다.

### 기존 라우팅 (서버 사이드 라우팅)

기존 라우팅, 또는 서버 사이드 라우팅은 페이지 요청을 서버에서 처리하는 방식입니다. 사용자가 링크를 클릭하거나 URL을 입력하면, 브라우저는 서버에 요청을 보내고, 서버는 해당 요청에 맞는 HTML 페이지를 응답으로 보냅니다.

장점:

1. SEO 최적화: 서버 사이드 렌더링은 검색 엔진 크롤러가 페이지의 콘텐츠를 쉽게 읽을 수 있도록 해줍니다.
2. 초기 로드 속도: 처음 페이지를 로드할 때 서버에서 전체 HTML을 렌더링하므로, 브라우저는 이미 렌더링된 페이지를 받습니다.
3. 보안: 클라이언트 측 코드가 노출되지 않기 때문에, 보안상 더 안전할 수 있습니다.

단점:

1. 페이지 전환 시 지연: 페이지가 새로 고쳐지면서 전체 페이지가 다시 로드되므로, 사용자 경험이 느려질 수 있습니다.
2. 서버 부하: 모든 페이지 요청이 서버로 전달되기 때문에, 서버의 부하가 증가할 수 있습니다.

### 클라이언트 사이드 라우팅

클라이언트 사이드 라우팅은 SPA(Single Page Application)에서 주로 사용됩니다. 클라이언트 측에서 JavaScript가 URL 변경을 감지하고, 필요한 데이터를 로드한 후, 페이지 콘텐츠를 동적으로 업데이트합니다. 이 경우 전체 페이지를 새로 고치지 않고도 사용자에게 새로운 콘텐츠를 보여줄 수 있습니다.

장점:

1. 빠른 페이지 전환: 페이지 전환 시 서버와의 추가 요청 없이 클라이언트 측에서만 콘텐츠를 업데이트하므로 빠릅니다.
2. 향상된 사용자 경험: 사용자 경험이 매끄럽고 반응성이 좋습니다. 특히 자주 변경되는 페이지에서 효과적입니다.
3. 리소스 절약: 서버로부터 HTML 페이지를 매번 받아오지 않기 때문에, 네트워크 트래픽과 서버 부하를 줄일 수 있습니다.

단점:

1. SEO 문제: 클라이언트 측에서 콘텐츠를 동적으로 로드하기 때문에, 검색 엔진 크롤러가 콘텐츠를 제대로 인식하지 못할 수 있습니다. 하지만 서버 사이드 렌더링(SSR)이나 프리렌더링을 통해 이 문제를 일부 해결할 수 있습니다.
2. 초기 로드 시간: 클라이언트에서 초기 JavaScript 파일을 로드해야 하므로, 초기 로드 시간이 길어질 수 있습니다.
3. 보안 우려: 클라이언트 측 코드가 노출되기 때문에, 보안상의 취약점이 생길 수 있습니다.

결론적으로, 기존 라우팅은 전통적인 서버 기반 애플리케이션에서 유리하며, 클라이언트 사이드 라우팅은 SPA에서 더 빠르고 부드러운 사용자 경험을 제공합니다. 각 방식은 애플리케이션의 요구 사항과 목적에 따라 선택하는 것이 좋습니다.

네, 맞습니다. Next.js는 다음과 같은 방식으로 동작합니다:

1. 첫 요청 시: 클라이언트가 페이지를 처음 요청할 때, 서버는 해당 페이지의 HTML 파일을 생성하여 클라이언트에 전송합니다. 이 과정에서 Next.js는 서버 사이드 렌더링(SSR)을 사용하여 페이지를 렌더링합니다. 이렇게 하면 클라이언트는 페이지의 초기 HTML을 받아볼 수 있어 SEO와 성능 측면에서 유리합니다.

2. 클라이언트 라우팅: 이후에는 클라이언트 사이드에서 라우팅을 처리합니다. 즉, 페이지가 전환될 때마다 서버에서 전체 페이지를 새로 받아오는 것이 아니라, JavaScript를 사용하여 필요한 부분만 업데이트합니다. 이를 통해 빠르고 부드러운 사용자 경험을 제공할 수 있습니다. 클라이언트 사이드에서 필요한 데이터는 API 호출 등을 통해 가져오고, 페이지는 클라이언트에서 렌더링됩니다.

이러한 접근 방식은 Next.js가 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)을 조합하여, 초기 로딩 성능과 이후 사용자 경험을 모두 개선할 수 있도록 설계된 것입니다.

네, 정확히 말씀하신 대로입니다. Next.js는 초기 로딩 시에는 서버 사이드 렌더링(SSR)을 사용하여 전체 HTML을 클라이언트에 전달하고, 이후 페이지 전환 시에는 SPA(싱글 페이지 애플리케이션)처럼 동작합니다.

여기서 핵심은:

1. 초기 로딩: 서버가 페이지의 전체 HTML을 렌더링하여 클라이언트에 전달합니다. 이는 페이지가 처음 요청될 때 SEO와 초기 로딩 성능을 개선하는 데 도움을 줍니다.

2. 클라이언트 라우팅: 페이지가 로드된 후, 사용자 상호작용에 따라 클라이언트 사이드 라우팅을 처리합니다. 이때, JavaScript를 사용하여 필요한 데이터만 가져오고, 페이지 전환을 빠르고 부드럽게 수행합니다. 이 과정에서 페이지 전체를 다시 로드할 필요 없이 필요한 부분만 업데이트하게 됩니다.

이러한 방식은 Next.js가 SSR과 CSR을 조합하여, 초기 로딩 성능을 극대화하고, 이후 사용자 경험을 매끄럽게 유지할 수 있도록 합니다. SPA처럼 클라이언트 측에서 동적으로 페이지를 업데이트하는 이점을 살리면서도, 초기 렌더링에서 서버의 지원을 받아 효율적인 SEO와 성능을 유지할 수 있습니다.

History API와 `window.location`은 웹 브라우저에서 페이지의 URL을 관리하고 조작하는 데 사용되지만, 그 목적과 사용 방식에 차이가 있습니다. 이 두 가지를 비교하여 차이점을 설명하겠습니다.

웹 개발에서 중요한 역할을 하는 History API, Navigation API, 그리고 Location 인터페이스에 대해 설명하겠습니다.

### 1. History API

history.state (새로고침 삭제 안됨 why?)
History API는 브라우저의 세션 기록(history stack)을 제어하는 데 사용됩니다. 사용자는 웹 페이지를 탐색할 때 브라우저의 뒤로 가기, 앞으로 가기 버튼을 자주 사용하는데, History API는 이러한 탐색 동작을 프로그래밍적으로 제어할 수 있게 합니다. 주요 메서드로는 다음이 있습니다:

- `history.pushState(state, title, url)`: 새로운 상태를 세션 기록에 추가합니다. 사용자가 새 페이지로 이동한 것처럼 보이게 하지만, 실제로는 URL만 바뀝니다.
- `history.replaceState(state, title, url)`: 현재 상태를 새 상태로 교체합니다. 페이지를 새로고침하지 않고 URL을 변경할 수 있습니다.
- `history.back()`, `history.forward()`, `history.go(n)`: 사용자가 브라우저의 뒤로 가기 또는 앞으로 가기 버튼을 누르는 것처럼 특정 위치로 이동합니다.

이 API는 주로 SPA(Single Page Application)에서 유용하게 사용되며, URL을 유지하면서 동적 콘텐츠를 로드하는 데 사용됩니다.

### 2. Navigation API

Navigation API는 웹 페이지 탐색과 관련된 다양한 기능을 제공합니다. 이 API는 현재 개발 중인 표준이며, 기존의 History API를 대체하거나 보완할 수 있는 기능들을 포함하고 있습니다. Navigation API는 페이지 전환이나 상태 변경과 관련된 다양한 이벤트와 메서드를 제공하여, 웹 애플리케이션이 사용자 경험을 보다 정밀하게 제어할 수 있도록 합니다.

Navigation API의 주요 기능은 다음과 같습니다:

- `navigate()`: 페이지 간의 탐색을 제어할 수 있습니다. 페이지를 로드하거나 리디렉션할 때 이 메서드를 사용할 수 있습니다.
- `reload()`: 현재 페이지를 새로고침합니다.
- `abort()`: 현재 진행 중인 탐색을 중단할 수 있습니다.
- 이벤트들: `navigatesuccess`, `navigateerror` 등 다양한 탐색 관련 이벤트를 제공합니다.

이 API는 아직 널리 사용되지는 않지만, 웹 애플리케이션의 네이게이션을 더 세밀하게 관리할 수 있도록 합니다.

### 3. Location 인터페이스

Location 인터페이스는 현재 문서의 URL을 나타내며, URL을 조작하고 새로고침하거나, 다른 페이지로 이동하는 기능을 제공합니다. 주로 다음과 같은 프로퍼티와 메서드를 포함합니다:

- `location.href`: 현재 페이지의 URL을 가져오거나 설정합니다. 이 값을 설정하면 해당 URL로 페이지가 이동합니다.
- `location.assign(url)`: 주어진 URL로 이동합니다.
- `location.replace(url)`: 현재 페이지를 새 페이지로 대체합니다. `replace` 메서드는 브라우저의 뒤로 가기 버튼으로 다시 돌아올 수 없는 방식으로 페이지를 변경합니다.
- `location.reload()`: 현재 페이지를 새로고침합니다.
- `location.pathname`, `location.search`, `location.hash`: URL의 특정 부분에 접근하거나 이를 변경할 수 있습니다.

이 인터페이스는 브라우저의 기본 탐색 동작을 제어하는 데 사용되며, URL에 대한 다양한 작업을 수행할 수 있습니다.

이 세 가지 API와 인터페이스는 웹 애플리케이션의 네비게이션과 URL 관리에 중요한 도구들로, 사용자 경험을 최적화하는 데 큰 도움이 됩니다.

클라이언트 사이드 라우팅의 핵심

window.location.href = '/'
history.pushState
history.replaceState

history.state 세션 유지됨

## encodeURI encodeURIComponent

| 함수                 | 인코딩 대상                                   | 사용 예시                      |
| -------------------- | --------------------------------------------- | ------------------------------ |
| `encodeURI`          | URL 전체, 구조 문자(`:/=?&`) 제외             | 전체 URL 인코딩                |
| `encodeURIComponent` | 개별 구성 요소, 구조 문자까지 인코딩          | 쿼리 파라미터 값 인코딩        |
| `decodeURI`          | `encodeURI`로 인코딩된 URL 디코딩             | 인코딩된 URL 복원              |
| `decodeURIComponent` | `encodeURIComponent`로 인코딩된 문자열 디코딩 | 인코딩된 쿼리 파라미터 값 복원 |
