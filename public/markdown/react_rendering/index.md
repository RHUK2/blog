---
folderName: react_rendering
updatedAt: 2024-09-12
title: React Rendering
tag: react
isPublished: true
---

# Example1

- [가상 돔(Virtual DOM)](#가상-돔virtual-dom)
  - [사용자 입력 제한](#사용자-입력-제한)
- [JSX(JavaScript XML)](#jsxjavascript-xml)
  - [텍스트 줄바꿈](#텍스트-줄바꿈)
- [dangerouslySetInnerHTML](#dangerouslysetinnerhtml)
  - [`innerHTML`](#innerhtml)
  - [`innerText`](#innertext)
  - [`textContent`](#textcontent)
  - [비교 요약](#비교-요약)
- [요소 렌더링](#요소-렌더링)
- [렌더링](#렌더링)
  - [결론](#결론)

## 가상 돔(Virtual DOM)

리액트는 실제 돔을 기반으로 만들어진 가상 돔이 존재한다. 정의해놓은 상태 값이 변경되어 가상 돔의 변화가 일어나게 되면 실제 돔과 비교하여 변경된 부분만 수정한 후에 리렌더링이 이루어진다.

![img](images/virtual_dom.png)

### 사용자 입력 제한

개발하다 보면 사용자 입력을 제한해야 하는 상황이 생긴다. 일반적으로 생각나는 방법은 입력 요소의 `disabled` 속성을 주는 방법 또는 해당 화면을 마스킹 처리해서 클릭이 일어나지 않도록 방지하는 것이다.

위 방법은 개발자 도구에서 `disabled` 값을 수정하거나 마스킹 스타일을 수정해서 클릭할 수 있는 상태로 변경이 가능하다. 이런 이유로 클라이언트에서는 데이터 무결성을 완벽히 체크하지 못하므로 서버에서 꼼꼼한 예외처리가 필요하다. 리액트에서는 가상 돔을 이용하므로 `disabled` 값이 상태 값에 의존하는 경우에는 입력 제한이 가능하다. 속성 값을 수정해도 상태 값이 변경되지 않아 리렌더링이 발생하지 않고 화면 상에서는 클릭 가능해보이지만 클릭해보면 이벤트가 발생하지 않는다.

인증된 사용자의 토큰이 필요한 API의 경우 추적도 가능하고 인증된 사용자가 위와 같은 편법을 쓸 확률을 낮기 떄문에 비교적 위험성이 적지만, 토큰이 필요없는 API나 중요한 정보가 오가는 API(가격, 사용자 정보, 결제 등)가 동작하는 입력 요소의 경우 보안적인 부분을 꼼꼼히 신경쓰는 것이 좋다.

## JSX(JavaScript XML)

전통적인 웹은 HTML, CSS, JavaScript를 기반으로 구축됐었다. 하지만 웹이 발전하면서 로직이 콘텐츠를 결정하는 경우가 많아졌다. 그래서 HTML을 자바스크립트가 제어하는 형태가 탄생했다. 이것이 바로 React에서 렌더링 로직과 마크업이 같은 위치, 즉 컴포넌트에 함께 존재하는 이유다.

- JSX와 React는 별개의 개념이다. JSX는 구문 확장이고 React는 자바스크립트 라이브러리이다.
- 중괄호(`{}`)를 사용하면 자바스크립트 로직과 변수를 마크업으로 가져올 수 있다.
- 컴포넌트에서 여러 요소를 반환하려면 단일 부모 태그로 래핑하거나 Fragment(`<>`, `</>`)를 래핑해야 한다.
  - JSX는 HTML처럼 보이지만 내부적으로는 일반 JavaScript 객체로 변환된다. 함수에서 두 개의 객체를 배열로 래핑하지 않고는 반환할 수 없는 것과 같은 원리다.
- JSX로 작성된 속성은 객체의 키가 된다. 그래서 속성은 모두 카멜 케이스로 작성해야 하고 대시를 포함하거나 `class`와 같은 예약어를 사용할 수 없다.
  - 역사적인 이유로 `aria-*` 및 `data-*` 속성은 HTML에서와 같이 대시를 사용하여 작성된다.

### 텍스트 줄바꿈

HTML에서는 `\n` 줄바꿈 특수문자를 인식하지 못해서 `<br/>` 태그를 사용하거나 Javascript를 이용해 `textContent` 값에 `\n`을 포함한 문자열을 입력한다.
React에서는 JSX를 통해 `{}` 중괄호를 이용해 쉽게 줄바꿈이 가능하다.

## dangerouslySetInnerHTML

https://www.freecodecamp.org/news/innerhtml-vs-innertext-vs-textcontent/

### `innerHTML`

특징:

- HTML 태그 파싱: HTML 태그를 포함한 문자열을 설정하면, 브라우저는 이를 HTML로 파싱하여 DOM 트리로 변환한다.
- 보안 문제: 사용자 입력을 그대로 `innerHTML`에 삽입하면 XSS(교차 사이트 스크립팅) 공격에 취약할 수 있다.
- 읽기 및 쓰기: 요소의 HTML 구조를 읽거나, 새로운 HTML 콘텐츠를 추가할 수 있다.

### `innerText`

특징:

- 스타일 반영: 요소의 CSS 스타일에 따라 숨겨진 텍스트는 무시합니다.
- 읽기 및 쓰기: 요소의 텍스트 콘텐츠를 읽거나, 새로운 텍스트로 변경할 수 있습니다.
- 텍스트 포맷 유지: 공백과 줄바꿈 등의 텍스트 포맷을 유지합니다.

### `textContent`

특징:

- HTML 태그 무시: HTML 태그를 포함하지 않고, 요소 내의 모든 텍스트를 단순 문자열로 반환합니다.
- 빠른 성능: `innerText`보다 성능이 더 빠르며, 스타일을 고려하지 않습니다.
- 읽기 및 쓰기: 요소의 텍스트 콘텐츠를 읽거나, 새로운 텍스트로 변경할 수 있습니다.

### 비교 요약

- `innerHTML`: HTML 태그를 포함한 전체 콘텐츠를 읽고 쓰기 위해 사용. XSS 공격에 주의 필요.
- `innerText`: 사용자가 볼 수 있는 텍스트만을 읽고 쓰기 위해 사용. CSS 스타일을 반영.
- `textContent`: 모든 텍스트 콘텐츠를 단순 문자열로 읽고 쓰기 위해 사용. 성능이 빠름.

## 요소 렌더링

```tsx
const MyComponent = ({ items }) => {
  return <div>{items.map((item) => item.shouldRender && <div key={item.id}>{item.content}</div>)}</div>;
};

const MyComponent = ({ items }) => {
  return (
    <div>
      {items.map((item) => (
        <div key={item.id} style={{ display: item.shouldRender ? 'block' : 'none' }}>
          {item.content}
        </div>
      ))}
    </div>
  );
};
```

## 렌더링

1. 조건문을 사용한 요소 렌더링:
   - 장점: 조건문을 사용해 요소를 렌더링하면, 해당 요소가 아예 DOM에 추가되지 않거나 제거된다. 이는 불필요한 요소들이 메모리와 리소스를 차지하지 않게 하기 때문에 성능에 긍정적인 영향을 미친다.
   - 단점: 요소가 다시 나타나야 할 때, 새롭게 렌더링 되어야 하므로 초기 렌더링 비용이 발생할 수 있다.

2. `display` 속성을 이용한 요소 렌더링:
   - 장점: CSS `display: none`을 사용하면 요소가 DOM에는 남아 있지만, 화면에 보이지 않게 된다. 요소가 다시 나타날 때 렌더링 비용이 적다.
   - 단점: 요소가 DOM에 계속 남아 있기 때문에 메모리를 차지하며, 특히 많은 수의 요소가 있을 때 성능에 부정적인 영향을 미칠 수 있다.

렌더링 최적화 측면에서 보면, 조건문을 사용해 요소를 렌더링하는 것이 더 효과적이다. 이는 불필요한 요소들이 DOM에 존재하지 않게 하여 메모리 사용을 줄이고, 성능에 긍정적인 영향을 미치기 때문이다. 요소가 자주 나타나고 사라지는 상황이 아니라면 조건문을 사용하는 것이 좋다.

다만, 요소가 자주 나타나고 사라져서 렌더링 비용이 커지는 경우에는 `display` 속성을 사용해 보이지 않게 처리하는 것이 나을 수도 있다. 이 경우에도 요소의 수가 많지 않거나, 요소의 상태를 유지해야 하는 상황에서 유리할 수 있다.

전반적으로 설명하신 내용은 리액트의 동작 방식에 대해 매우 잘 설명하고 있습니다. 아래에서 몇 가지 주요 개념을 더 구체적으로 살펴보겠습니다.

1. 가상 DOM과 마운트(Mount)
   가상 DOM: 리액트는 UI를 렌더링하기 위해 가상 DOM을 사용합니다. 이는 실제 DOM의 복사본으로, 상태가 변경될 때 효율적으로 업데이트하기 위한 기술입니다.
   마운트: 처음 컴포넌트가 DOM에 추가되는 과정을 마운트라고 하며, 이 과정에서 리액트는 JSX 코드를 바탕으로 가상 DOM을 렌더링하고, 이를 실제 DOM에 반영합니다.
2. 리렌더링(Rendering)
   상태(state)가 변경되면 리액트는 새로운 가상 DOM을 생성합니다. 이후 이전 가상 DOM과 새로운 가상 DOM을 비교(diffing)하여 변화가 있는 부분만 실제 DOM에 반영합니다. 이 과정을 통해 성능을 최적화 합니다.
3. 비교 방법
   리액트는 가상 DOM의 이전 상태와 새로운 상태를 비교하기 위해 여러 기준을 사용합니다. 주요 기준은 다음과 같습니다:

- 컴포넌트 이름: 동일한 컴포넌트 이름을 가진 요소들은 같은 유형의 컴포넌트로 간주하고 비교합니다.
- JSX 타입: 같은 유형의 요소는 비교를 수행합니다 (예: <div> vs. <span>).
- Props 변경 여부: 각 컴포넌트의 props가 변경되었는지를 확인하여 필요할 경우 리렌더링을 트리거합니다.
- Key 값: 리스트를 렌더링할 때는 key 값을 사용하여 각 요소의 고유성을 파악합니다. key 값이 변경될 경우 React는 새로운 요소로 간주하고, 이전 요소와의 연관성을 끊고 해당 요소를 새로 만들 수 있습니다.
- 위치: 같은 위치에 있는 요소들 간의 비교를 통해 최적화를 진행합니다.

추가 설명

- Composite Components: 리액트 컴포넌트가 중첩되어 있을 경우, 상위 컴포넌트가 리렌더링되면 하위 컴포넌트들도 영향을 받을 수 있습니다. 이 과정에서도 위에서 언급한 기준들이 적용됩니다.
- shouldComponentUpdate: 클래스형 컴포넌트에서 이 메소드를 구현하여 컴포넌트의 리렌더링 여부를 직접 제어할 수 있습니다.
- React.memo: 함수형 컴포넌트에서 리렌더링을 제어할 때 사용할 수 있는 HOC로, props가 같다면 리렌더링을 방지할 수 있습니다.
  이 외에도 다양한 최적화 기법들이 존재하지만, 기본적으로 말씀하신 내용은 정확하며, 리액트의 리렌더링 메커니즘을 잘 설명하고 있습니다. 추가적으로 궁금한 점이 있다면 질문해 주세요!

그렇습니다. 리액트는 객체 정보를 바탕으로 DOM 요소를 생성해냅니다.  
리액트는 가상 DOM(Virtual DOM)이라는 개념을 사용하여 실제 DOM을 효율적으로 업데이트합니다. 이 과정은 다음과 같이 진행됩니다:

1. 가상 DOM 생성:  
   리액트는 `React.createElement`를 통해 객체 형태의 가상 DOM 요소를 생성합니다. 이 객체는 요소의 타입, 속성(props), 자식 요소(children) 등을 포함합니다.

   예시:

   ```ts
   const element = React.createElement('div', { className: 'container' }, 'Hello, World!');
   ```

   위 코드는 다음과 같은 객체를 생성합니다:

   ```ts
   {
     type: 'div',
     props: {
       className: 'container',
       children: 'Hello, World!'
     }
   }
   ```

2. 가상 DOM 트리 구성:  
   여러 가상 DOM 요소가 중첩되면, 리액트는 이를 트리 구조로 구성합니다. 이 트리는 실제 DOM과 유사하지만, 메모리 상에만 존재하는 가벼운 표현입니다.

3. 실제 DOM과 비교 및 업데이트:  
   리액트는 가상 DOM 트리를 이전 상태와 비교하여 변경된 부분만 찾아냅니다(Diffing 알고리즘). 이후, 변경된 부분만 실제 DOM에 반영합니다. 이 과정을 재조정(Reconciliation)이라고 합니다.

4. 효율적인 렌더링:  
   가상 DOM을 사용함으로써, 리액트는 불필요한 DOM 조작을 최소화하고 성능을 최적화합니다.

### 결론

리액트는 객체 정보(가상 DOM)를 바탕으로 DOM 요소를 생성하고, 이를 효율적으로 업데이트합니다. 이는 리액트의 핵심 원리 중 하나로, 빠르고 반응성 있는 웹 애플리케이션을 구축하는 데 기여합니다. 🚀
