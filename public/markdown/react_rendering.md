---
fileName: react_rendering
updatedAt: 2024-09-12
title: React Rendering
tag: react
isPublished: true
---

# Example1

- [가상 돔(Virtual DOM)](#가상-돔virtual-dom)
  - [사용자 입력 제한](#사용자-입력-제한)
- [JSX(JavaScript XML)](#jsxjavascript-xml)
  - [텍스트 줄바꿈](#텍스트-줄바꿈)
- [dangerouslySetInnerHTML](#dangerouslysetinnerhtml)
  - [`innerHTML`](#innerhtml)
  - [`innerText`](#innertext)
  - [`textContent`](#textcontent)
  - [비교 요약](#비교-요약)
- [요소 렌더링](#요소-렌더링)

## 가상 돔(Virtual DOM)

리액트는 실제 돔을 기반으로 만들어진 가상 돔이 존재한다. 정의해놓은 상태 값이 변경되어 가상 돔의 변화가 일어나게 되면 실제 돔과 비교하여 변경된 부분만 수정한 후에 리렌더링이 이루어진다.

![img](images/virtual_dom.png)

### 사용자 입력 제한

개발하다 보면 사용자 입력을 제한해야 하는 상황이 생긴다. 일반적으로 생각나는 방법은 입력 요소의 `disabled` 속성을 주는 방법 또는 해당 화면을 마스킹 처리해서 클릭이 일어나지 않도록 방지하는 것이다.

위 방법은 개발자 도구에서 `disabled` 값을 수정하거나 마스킹 스타일을 수정해서 클릭할 수 있는 상태로 변경이 가능하다. 이런 이유로 클라이언트에서는 데이터 무결성을 완벽히 체크하지 못하므로 서버에서 꼼꼼한 예외처리가 필요하다. 리액트에서는 가상 돔을 이용하므로 `disabled` 값이 상태 값에 의존하는 경우에는 입력 제한이 가능하다. 속성 값을 수정해도 상태 값이 변경되지 않아 리렌더링이 발생하지 않고 화면 상에서는 클릭 가능해보이지만 클릭해보면 이벤트가 발생하지 않는다.

인증된 사용자의 토큰이 필요한 API의 경우 추적도 가능하고 인증된 사용자가 위와 같은 편법을 쓸 확률을 낮기 떄문에 비교적 위험성이 적지만, 토큰이 필요없는 API나 중요한 정보가 오가는 API(가격, 사용자 정보, 결제 등)가 동작하는 입력 요소의 경우 보안적인 부분을 꼼꼼히 신경쓰는 것이 좋다.

## JSX(JavaScript XML)

전통적인 웹은 HTML, CSS, JavaScript를 기반으로 구축됐었다. 하지만 웹이 발전하면서 로직이 콘텐츠를 결정하는 경우가 많아졌다. 그래서 HTML을 자바스크립트가 제어하는 형태가 탄생했다. 이것이 바로 React에서 렌더링 로직과 마크업이 같은 위치, 즉 컴포넌트에 함께 존재하는 이유다.

- JSX와 React는 별개의 개념이다. JSX는 구문 확장이고 React는 자바스크립트 라이브러리이다.
- 중괄호(`{}`)를 사용하면 자바스크립트 로직과 변수를 마크업으로 가져올 수 있다.
- 컴포넌트에서 여러 요소를 반환하려면 단일 부모 태그로 래핑하거나 Fragment(`<>`, `</>`)를 래핑해야 한다.
  - JSX는 HTML처럼 보이지만 내부적으로는 일반 JavaScript 객체로 변환된다. 함수에서 두 개의 객체를 배열로 래핑하지 않고는 반환할 수 없는 것과 같은 원리다.
- JSX로 작성된 속성은 객체의 키가 된다. 그래서 속성은 모두 카멜 케이스로 작성해야 하고 대시를 포함하거나 `class`와 같은 예약어를 사용할 수 없다.
  - 역사적인 이유로 `aria-*` 및 `data-*` 속성은 HTML에서와 같이 대시를 사용하여 작성된다.

### 텍스트 줄바꿈

HTML에서는 `\n` 줄바꿈 특수문자를 인식하지 못해서 `<br/>` 태그를 사용하거나 Javascript를 이용해 `textContent` 값에 `\n`을 포함한 문자열을 입력한다.
React에서는 JSX를 통해 `{}` 중괄호를 이용해 쉽게 줄바꿈이 가능하다.

## dangerouslySetInnerHTML

https://www.freecodecamp.org/news/innerhtml-vs-innertext-vs-textcontent/

### `innerHTML`

특징:

- HTML 태그 파싱: HTML 태그를 포함한 문자열을 설정하면, 브라우저는 이를 HTML로 파싱하여 DOM 트리로 변환한다.
- 보안 문제: 사용자 입력을 그대로 `innerHTML`에 삽입하면 XSS(교차 사이트 스크립팅) 공격에 취약할 수 있다.
- 읽기 및 쓰기: 요소의 HTML 구조를 읽거나, 새로운 HTML 콘텐츠를 추가할 수 있다.

### `innerText`

특징:

- 스타일 반영: 요소의 CSS 스타일에 따라 숨겨진 텍스트는 무시합니다.
- 읽기 및 쓰기: 요소의 텍스트 콘텐츠를 읽거나, 새로운 텍스트로 변경할 수 있습니다.
- 텍스트 포맷 유지: 공백과 줄바꿈 등의 텍스트 포맷을 유지합니다.

### `textContent`

특징:

- HTML 태그 무시: HTML 태그를 포함하지 않고, 요소 내의 모든 텍스트를 단순 문자열로 반환합니다.
- 빠른 성능: `innerText`보다 성능이 더 빠르며, 스타일을 고려하지 않습니다.
- 읽기 및 쓰기: 요소의 텍스트 콘텐츠를 읽거나, 새로운 텍스트로 변경할 수 있습니다.

### 비교 요약

- `innerHTML`: HTML 태그를 포함한 전체 콘텐츠를 읽고 쓰기 위해 사용. XSS 공격에 주의 필요.
- `innerText`: 사용자가 볼 수 있는 텍스트만을 읽고 쓰기 위해 사용. CSS 스타일을 반영.
- `textContent`: 모든 텍스트 콘텐츠를 단순 문자열로 읽고 쓰기 위해 사용. 성능이 빠름.

## 요소 렌더링

```ts
const MyComponent = ({ items }) => {
  return <div>{items.map((item) => item.shouldRender && <div key={item.id}>{item.content}</div>)}</div>;
};

const MyComponent = ({ items }) => {
  return (
    <div>
      {items.map((item) => (
        <div key={item.id} style={{ display: item.shouldRender ? 'block' : 'none' }}>
          {item.content}
        </div>
      ))}
    </div>
  );
};
```

1. 조건문을 사용한 요소 렌더링:

   - 장점: 조건문을 사용해 요소를 렌더링하면, 해당 요소가 아예 DOM에 추가되지 않거나 제거된다. 이는 불필요한 요소들이 메모리와 리소스를 차지하지 않게 하기 때문에 성능에 긍정적인 영향을 미친다.
   - 단점: 요소가 다시 나타나야 할 때, 새롭게 렌더링 되어야 하므로 초기 렌더링 비용이 발생할 수 있다.

2. `display` 속성을 이용한 요소 렌더링:
   - 장점: CSS `display: none`을 사용하면 요소가 DOM에는 남아 있지만, 화면에 보이지 않게 된다. 요소가 다시 나타날 때 렌더링 비용이 적다.
   - 단점: 요소가 DOM에 계속 남아 있기 때문에 메모리를 차지하며, 특히 많은 수의 요소가 있을 때 성능에 부정적인 영향을 미칠 수 있다.

렌더링 최적화 측면에서 보면, 조건문을 사용해 요소를 렌더링하는 것이 더 효과적이다. 이는 불필요한 요소들이 DOM에 존재하지 않게 하여 메모리 사용을 줄이고, 성능에 긍정적인 영향을 미치기 때문이다. 요소가 자주 나타나고 사라지는 상황이 아니라면 조건문을 사용하는 것이 좋다.

다만, 요소가 자주 나타나고 사라져서 렌더링 비용이 커지는 경우에는 `display` 속성을 사용해 보이지 않게 처리하는 것이 나을 수도 있다. 이 경우에도 요소의 수가 많지 않거나, 요소의 상태를 유지해야 하는 상황에서 유리할 수 있다.
