# Big O

- [단일 연결 리스트 (Singly Linked List)](#단일-연결-리스트-singly-linked-list)
- [이중 연결 리스트 (Doubly Linked List)](#이중-연결-리스트-doubly-linked-list)
- [단일 연결 리스트와 이중 연결 리스트의 비교](#단일-연결-리스트와-이중-연결-리스트의-비교)

## 단일 연결 리스트 (Singly Linked List)

구조:

- 각 노드에는 두 가지 정보가 저장됩니다:

1. 데이터(data)
2. 다음 노드로의 참조(next pointer)

- 노드는 한 방향으로만 연결되어 있습니다.

연산별 빅오 시간 복잡도:

| 연산          | 시간 복잡도      | 설명                                                                                                                                  |
| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 읽기 (Access) | `O(n)`           | 특정 인덱스에 있는 값을 읽기 위해서, 첫 번째 노드부터 순차적으로 탐색해야 합니다.                                                     |
| 삽입 (Insert) | `O(1)` (앞)      | 첫 번째 노드(리스트의 맨 앞)에 삽입하는 경우, 단순히 새 노드를 생성하고, 새 노드의 `next`를 기존 첫 노드에 연결하면 되기 때문에 O(1). |
|               | `O(n)` (뒤)      | 리스트의 끝에 삽입할 경우, 끝까지 탐색한 후에 새로운 노드를 추가해야 하므로 O(n).                                                     |
| 삭제 (Delete) | `O(1)` (앞)      | 첫 번째 노드를 삭제하는 경우, 단순히 헤더 포인터를 다음 노드로 변경하면 됩니다.                                                       |
|               | `O(n)` (중간/뒤) | 리스트의 중간이나 끝에서 요소를 삭제하려면, 삭제하려는 요소의 직전 노드까지 탐색해야 하므로 O(n).                                     |
| 탐색 (Search) | `O(n)`           | 원하는 값을 찾기 위해 리스트를 처음부터 순차적으로 검색해야 합니다.                                                                   |

---

## 이중 연결 리스트 (Doubly Linked List)

구조:

- 각 노드에는 세 가지 정보가 저장됩니다:

1. 데이터(data)
2. 이전 노드로의 참조(prev pointer)
3. 다음 노드로의 참조(next pointer)

- 노드는 양방향으로 연결되어 있습니다(앞으로도, 뒤로도 이동 가능).

연산별 빅오 시간 복잡도:

| 연산          | 시간 복잡도    | 설명                                                                                                                                 |
| ------------- | -------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| 읽기 (Access) | `O(n)`         | 특정 인덱스를 읽기 위해 리스트를 순차적으로 접근해야 하므로 O(n). 그러나 양방향 참조로 인해 필요 시 뒤에서부터 탐색할 수도 있습니다. |
| 삽입 (Insert) | `O(1)` (앞/뒤) | 리스트의 양 끝에 삽입할 때는 단순히 헤더나 테일 포인터를 조정하면 되므로 O(1).                                                       |
|               | `O(n)` (중간)  | 중간에 삽입하려면 삽입할 위치까지 탐색해야 하므로 O(n).                                                                              |
| 삭제 (Delete) | `O(1)` (앞/뒤) | 맨 앞 또는 맨 뒤 노드를 삭제할 경우, 헤더나 테일 포인터만 변경하면 되기 때문에 O(1).                                                 |
|               | `O(n)` (중간)  | 중간 노드를 삭제하려면 삭제 위치까지 탐색한 뒤 이전 및 다음 노드를 재연결해야 하므로 O(n).                                           |
| 탐색 (Search) | `O(n)`         | 단일 연결 리스트와 마찬가지로 순차 탐색이 필요하며, 값이 찾는 값에 따라 최악의 경우 리스트를 모두 순회해야 함.                       |

## 단일 연결 리스트와 이중 연결 리스트의 비교

| 특성                | 단일 연결 리스트       | 이중 연결 리스트           |
| ------------------- | ---------------------- | -------------------------- |
| 구조                | 단방향 연결            | 양방향 연결                |
| 메모리 사용         | 적음                   | 더 많음 (양방향 참조 추가) |
| 삽입 및 삭제 편의성 | 맨 앞 삽입/삭제는 유리 | 맨 앞/뒤 삽입/삭제 유리    |
| 탐색 방향           | 한 방향 (처음 → 끝)    | 양방향 탐색 가능           |

- 단일 연결 리스트는 메모리 사용량이 적고, 구현이 비교적 간단하다.  
  → 삽입, 삭제를 자주 수행해야 하고 방향성이 중요하지 않을 경우 적합하다.

- 이중 연결 리스트는 양방향 추적이 가능하므로 특정 위치에서 삽입/삭제가 더 빠르게 이루어질 수 있다.  
  → 복잡한 탐색(앞, 뒤로 이동)이나 양방향 탐색이 필요한 경우 적합하다.
