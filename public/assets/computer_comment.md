# 컴퓨터 구조 및 운영체제 궁금증 해결

- [cpu는 이진수로 이루어진 명령어에서 연산코드와 오퍼랜드를 어떻게 구분하지?](#cpu는-이진수로-이루어진-명령어에서-연산코드와-오퍼랜드를-어떻게-구분하지)
- [cpu 내부에도 버스가 존재하는가?](#cpu-내부에도-버스가-존재하는가)
- [예외(동기) vs 하드웨어 인터럽트(비동기)](#예외동기-vs-하드웨어-인터럽트비동기)
- [고립형 입출력 방식에서 입출력 장치를 위한 주소공간은 어디에 존재하는가?](#고립형-입출력-방식에서-입출력-장치를-위한-주소공간은-어디에-존재하는가)
- [시스템 버스 중 제어 버스는 여러가지 신호선이 따로 존재하는가?](#시스템-버스-중-제어-버스는-여러가지-신호선이-따로-존재하는가)
- [BIOS, UEFI, 부트로더](#bios-uefi-부트로더)
- [커널 vs 하이퍼바이저](#커널-vs-하이퍼바이저)
- [시스템 호출과 비시스템 호출 구분해보기](#시스템-호출과-비시스템-호출-구분해보기)
  - [시스템 호출 (System Call)](#시스템-호출-system-call)
  - [비시스템 호출 (Non-System Call)](#비시스템-호출-non-system-call)
- [애플리케이션이 메모리를 할당받는 과정](#애플리케이션이-메모리를-할당받는-과정)
- [프로세스와 스레드의 가장 큰 차이점](#프로세스와-스레드의-가장-큰-차이점)

## cpu는 이진수로 이루어진 명령어에서 연산코드와 오퍼랜드를 어떻게 구분하지?

- CPU는 명령어의 고정된 비트 구조를 사용하여 연산코드와 오퍼랜드를 구분한다.
- 명령어는 보통 워드 크기와 동일하거나 워드의 배수로 정해진다. 예를 들어, 32비트 CPU는 32비트(1워드) 명령어를 처리하며, 더 복잡한 명령어는 2워드(64비트)일 수도 있다.

예시:

`[연산코드 (8비트)] [오퍼랜드1 (12비트)] [오퍼랜드2 (12비트)]`

## cpu 내부에도 버스가 존재하는가?

CPU 내부의 레지스터들은 제어장치의 지시에 따라 내부 버스를 통해 제어되고, 데이터의 이동이 이루어진다.

## 예외(동기) vs 하드웨어 인터럽트(비동기)

- 인터럽트 발생 시 처리방식이 비슷하다.

  1. 상태 저장: CPU는 인터럽트나 폴트가 발생하면 현재 실행 중인 작업의 상태(레지스터, 프로그램 카운터 등)를 스택에 저장한다.
  2. 처리 루틴 실행: 인터럽트 벡터 테이블 또는 예외 처리 테이블을 참조해 적절한 처리 루틴(인터럽트 서비스 루틴 또는 예외 처리 핸들러)을 실행한다.
  3. 상태 복원: 처리가 끝나면 저장해 둔 상태를 복원하고, 원래 중단된 작업을 이어서 수행한다.

- 발생 원인이 다르다.

  - 동기: 이벤트가 CPU의 명령 실행과 직접적인 관련이 있을 때 발생한다. 즉, CPU가 특정 명령을 실행할 때 발생하는 이벤트이다. 그 명령어가 실행되지 않았다면 해당 이벤트도 발생하지 않는다.
  - 비동기: 이벤트가 CPU의 명령 실행과는 독립적으로, 외부 요인에 의해 언제든 발생할 수 있다. 즉, CPU가 현재 무슨 작업을 하고 있든 상관없이 외부 장치에서 발생하는 이벤트이다.

## 고립형 입출력 방식에서 입출력 장치를 위한 주소공간은 어디에 존재하는가?

입출력 장치를 위한 메모리는 입출력 장치 내부에 있거나, 장치의 레지스터와 같은 하드웨어 구성 요소에 포함된다.

## 시스템 버스 중 제어 버스는 여러가지 신호선이 따로 존재하는가?

제어 버스는 데이터 버스나 주소 버스처럼 단일 신호가 아니라, 다양한 제어 신호들이 결합된 구조이다.

- 메모리 읽기(Memory Read): CPU가 메모리에서 데이터를 읽을 때 사용하는 신호선
- 메모리 쓰기(Memory Write): CPU가 데이터를 메모리에 기록할 때 사용하는 신호선
- I/O 읽기(I/O Read): CPU가 입출력 장치에서 데이터를 읽을 때 사용하는 신호선
- I/O 쓰기(I/O Write): CPU가 데이터를 입출력 장치에 보낼 때 사용하는 신호선
- 인터럽트 요청(Interrupt Request): 하드웨어 장치가 CPU에 인터럽트를 요청할 때 사용하는 신호선
- 인터럽트 승인(Interrupt Acknowledge): CPU가 인터럽트 요청을 수락하고 처리할 때 사용하는 신호선
- 버스 요청(Bus Request): DMA 같은 장치가 시스템 버스를 사용하려고 요청할 때 사용하는 신호선
- 버스 승인(Bus Grant): CPU가 버스 요청을 승인해 DMA 장치가 버스를 사용할 수 있도록 할 때 사용하는 신호선
- 클락 신호(Clock Signal): 시스템의 동기화를 위한 신호선
- 리셋 신호(Reset): 시스템을 초기화할 때 사용하는 신호선

## BIOS, UEFI, 부트로더

BIOS (Basic Input/Output System):

- BIOS는 컴퓨터를 켤 때 가장 먼저 실행되는 펌웨어로, 하드웨어 초기화와 운영체제를 로드하는 역할을 한다.
- 하드웨어와 운영체제 사이에서 통신을 중재하며, 하드웨어 테스트(POST: Power-On Self-Test)를 한다.
- BIOS는 ROM에 저장된 코드로, 기본적으로 키보드, 모니터, 하드 드라이브 등의 하드웨어를 제어한다.

UEFI (Unified Extensible Firmware Interface):

- UEFI는 BIOS의 후속 기술로, 더 많은 기능과 빠른 부팅 속도를 제공한다.
- 그래픽 기반의 인터페이스와 보안 기능(Secure Boot)을 포함하며, 더 큰 하드 드라이브(2TB 이상의 드라이브)를 지원한다.
- UEFI는 운영체제와 하드웨어 간의 더 효율적인 인터페이스를 제공하며, 네트워크 기능이나 마우스 사용 등 고급 기능을 지원한다.

부트로더 (Bootloader):

- 부트로더는 BIOS나 UEFI가 하드웨어 초기화를 마친 후, 운영체제를 로드하는 프로그램이다.
- 컴퓨터가 켜지면 부트로더가 운영체제를 메모리에 올리고 실행하는 역할을 한다.
- 대표적인 부트로더로는 리눅스에서 많이 사용하는 GRUB, 윈도우의 Windows Boot Manager 등이 있다.

## 커널 vs 하이퍼바이저

![img](hypervisor.png)

| 특징        | 커널                                                                                         | 하이퍼바이저                                                    |
| ----------- | -------------------------------------------------------------------------------------------- | --------------------------------------------------------------- |
| 정의        | 운영 체제의 핵심 구성 요소로, 하드웨어 자원과 소프트웨어 간의 상호작용을 관리하는 소프트웨어 | 여러 가상 머신(VM)을 생성하고 관리하는 소프트웨어               |
| 주 목적     | 프로세스 관리, 메모리 관리, 파일 시스템 관리 등 운영 체제 기능 제공                          | 가상화, 자원 할당, 여러 운영 체제의 동시 실행 지원              |
| 자원 관리   | CPU, 메모리, I/O 장치 등 물리적 자원 관리                                                    | 물리적 자원을 가상 머신에 할당하고 관리                         |
| 문맥 교환   | 프로세스 간의 문맥 교환 관리                                                                 | 가상 머신 간의 문맥 교환 관리                                   |
| 의존성      | 하드웨어 위에서 직접 실행                                                                    | 하드웨어 위에서 또는 운영 체제 위의 가상화 계층으로 실행        |
| 형태        | 일반적으로 단일 커널 (자주 사용하는 구조)                                                    | 타입 1 하이퍼바이저(베어 메탈) 및 타입 2 하이퍼바이저(호스트형) |
| 설치 위치   | 물리적 하드웨어와 직접적으로 연결                                                            | 물리적 하드웨어 위에서 또는 운영 체제 내에서 간접적으로 실행    |
| 가상화 지원 | 기본적으로 가상화를 지원하지 않으며, 이를 위해 추가 소프트웨어가 필요                        | 기본적으로 가상화를 지원하며 여러 운영 체제를 동시에 실행 가능  |

## 시스템 호출과 비시스템 호출 구분해보기

### 시스템 호출 (System Call)

시스템 호출은 운영 체제의 기능을 직접 호출하는 것이며, 주로 파일 시스템, 네트워크, 프로세스 관리 등과 관련된 작업을 수행한다.

- `fs.readFile()`: 파일을 읽기 위한 시스템 호출
- `fs.writeFile()`: 파일에 쓰기 위한 시스템 호출
- `http.createServer()`: HTTP 서버를 생성하는 시스템 호출
- `net.createServer()`: TCP 서버를 생성하는 시스템 호출
- `child_process.exec()`: 자식 프로세스를 생성하는 시스템 호출

### 비시스템 호출 (Non-System Call)

비시스템 호출은 운영 체제와 직접적으로 상호작용하지 않는 코드로, 주로 메모리 내에서 데이터 처리나 계산을 수행한다.

- 숫자 계산, 문자열 조작 등
- 배열, 객체 등을 사용한 데이터 처리
- Promise 및 async/await를 사용한 비동기 처리, 시스템 자원에 의존하지 않는 경우

## 애플리케이션이 메모리를 할당받는 과정

고급 언어로 작성된 애플리케이션은 런타임 환경(Node.js, JVM, Python)을 통해 메모리를 할당받고, 런타임 환경은 운영체제에게 메모리를 할당받는 구조를 갖는다.

## 프로세스와 스레드의 가장 큰 차이점

- 프로세스와 스레드는 모두 문맥 스위칭을 통해 CPU에서 수행되지만, 프로세스는 각자의 독립적인 메모리 공간을 유지한다.
- 프로세스는 자원을 독립적으로 소유하고 안전성을 높이지만, 스레드는 동일한 자원을 공유하여 효율적인 통신과 자원 접근이 가능하다.

운영체제와 가상화 소프트웨어는 서로 보완적이며, 각각의 역할이 다르지만 상당히 밀접하게 연결되어 있습니다.

운영체제의 역할
메모리 관리:

운영체제는 물리적 메모리(RAM)를 관리하여 각 프로세스에 메모리를 할당하고, 메모리 사용을 최적화합니다.
가상 메모리 시스템을 통해 프로세스가 필요한 메모리를 할당하고, 프로세스간의 메모리 충돌을 방지하며, 메모리의 효율적인 사용을 도모합니다.
프로세스 관리:

운영체제는 실행 중인 프로세스들을 생성하고, 스케줄링하여 CPU 시간을 할당하며, 프로세스 간의 통신 및 동기화를 관리합니다.
입출력(I/O) 관리:

외부 장치(하드 드라이브, 프린터 등)와의 데이터 전송을 관리합니다.
파일 시스템 관리:

데이터를 저장하고 관리하는 파일 시스템을 제공하여 파일의 생성, 삭제, 접근 등을 처리합니다.
가상화의 역할
CPU 가상화:

가상화 소프트웨어(하이퍼바이저)는 물리적인 CPU를 여러 개의 가상 CPU로 나누어 사용하게 해줍니다. 여러 개의 가상 머신이 각각의 운영체제를 실행할 수 있도록 CPU 자원을 나누어 줍니다.
가상 머신이 CPU를 사용하는 방식에서 물리적 CPU를 할당하는데, 이는 시간 분할 방식(time-slicing)으로 이루어집니다.
메모리 가상화:

가상화 소프트웨어는 각 가상 머신에 메모리를 할당하고, 가상 머신의 메모리가 물리적 메모리의 어느 부분에 위치하는지를 관리합니다.
물리적 메모리를 효율적으로 분배하여 모든 가상 머신이 독립적으로 메모리를 사용할 수 있도록 합니다.
입출력(I/O) 가상화:

여러 가상 머신이 물리적 장치에 접근할 수 있도록 하며, 각 가상 머신이 장치에 독립적으로 접근할 수 있도록 관리합니다.
결론
따라서, 운영체제는 시스템 전체의 자원(메모리, CPU, I/O 장치 등)을 관리하며, 가상화는 이러한 자원 중 특히 CPU와 메모리를 가상화하여 여러 운영체제가 동시에 실행될 수 있게 하는 기술입니다. 두 시스템 모두 자원의 효율적 사용과 안정성을 목표로 하지만, 그 역할과 초점이 다릅니다.

이러한 상호작용 덕분에 우리는 하나의 물리적 기기에서 여러 운영체제를 실행하고 다양한 환경을 손쉽게 사용할 수 있습니다. 이해가 되셨나요? 추가적인 질문이 있다면 언제든지 물어보세요!
