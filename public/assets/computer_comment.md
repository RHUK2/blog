# 컴퓨터 구조 및 운영체제 궁금증 해결

- [cpu는 이진수로 이루어진 명령어에서 연산코드와 오퍼랜드를 어떻게 구분하지?](#cpu는-이진수로-이루어진-명령어에서-연산코드와-오퍼랜드를-어떻게-구분하지)
- [cpu 내부에도 버스가 존재하는가?](#cpu-내부에도-버스가-존재하는가)
- [예외(동기) vs 하드웨어 인터럽트(비동기)](#예외동기-vs-하드웨어-인터럽트비동기)
- [고립형 입출력 방식에서 입출력 장치를 위한 주소공간은 어디에 존재하는가?](#고립형-입출력-방식에서-입출력-장치를-위한-주소공간은-어디에-존재하는가)
- [시스템 버스 중 제어 버스는 여러가지 신호선이 따로 존재하는가?](#시스템-버스-중-제어-버스는-여러가지-신호선이-따로-존재하는가)
- [BIOS, UEFI, 부트로더](#bios-uefi-부트로더)
- [커널 vs 하이퍼바이저](#커널-vs-하이퍼바이저)
- [시스템 호출과 비시스템 호출 구분해보기](#시스템-호출과-비시스템-호출-구분해보기)
  - [시스템 호출 (System Call)](#시스템-호출-system-call)
  - [비시스템 호출 (Non-System Call)](#비시스템-호출-non-system-call)
- [애플리케이션이 메모리를 할당받는 과정](#애플리케이션이-메모리를-할당받는-과정)
- [프로세스와 스레드의 가장 큰 차이점](#프로세스와-스레드의-가장-큰-차이점)

## cpu는 이진수로 이루어진 명령어에서 연산코드와 오퍼랜드를 어떻게 구분하지?

- CPU는 명령어의 고정된 비트 구조를 사용하여 연산코드와 오퍼랜드를 구분한다.
- 명령어는 보통 워드 크기와 동일하거나 워드의 배수로 정해진다. 예를 들어, 32비트 CPU는 32비트(1워드) 명령어를 처리하며, 더 복잡한 명령어는 2워드(64비트)일 수도 있다.

예시:

`[연산코드 (8비트)] [오퍼랜드1 (12비트)] [오퍼랜드2 (12비트)]`

## cpu 내부에도 버스가 존재하는가?

CPU 내부의 레지스터들은 제어장치의 지시에 따라 내부 버스를 통해 제어되고, 데이터의 이동이 이루어진다.

## 예외(동기) vs 하드웨어 인터럽트(비동기)

- 인터럽트 발생 시 처리방식이 비슷하다.

  1. 상태 저장: CPU는 인터럽트나 폴트가 발생하면 현재 실행 중인 작업의 상태(레지스터, 프로그램 카운터 등)를 스택에 저장한다.
  2. 처리 루틴 실행: 인터럽트 벡터 테이블 또는 예외 처리 테이블을 참조해 적절한 처리 루틴(인터럽트 서비스 루틴 또는 예외 처리 핸들러)을 실행한다.
  3. 상태 복원: 처리가 끝나면 저장해 둔 상태를 복원하고, 원래 중단된 작업을 이어서 수행한다.

- 발생 원인이 다르다.

  - 동기: 이벤트가 CPU의 명령 실행과 직접적인 관련이 있을 때 발생한다. 즉, CPU가 특정 명령을 실행할 때 발생하는 이벤트이다. 그 명령어가 실행되지 않았다면 해당 이벤트도 발생하지 않는다.
  - 비동기: 이벤트가 CPU의 명령 실행과는 독립적으로, 외부 요인에 의해 언제든 발생할 수 있다. 즉, CPU가 현재 무슨 작업을 하고 있든 상관없이 외부 장치에서 발생하는 이벤트이다.

## 고립형 입출력 방식에서 입출력 장치를 위한 주소공간은 어디에 존재하는가?

입출력 장치를 위한 메모리는 입출력 장치 내부에 있거나, 장치의 레지스터와 같은 하드웨어 구성 요소에 포함된다.

## 시스템 버스 중 제어 버스는 여러가지 신호선이 따로 존재하는가?

제어 버스는 데이터 버스나 주소 버스처럼 단일 신호가 아니라, 다양한 제어 신호들이 결합된 구조이다.

- 메모리 읽기(Memory Read): CPU가 메모리에서 데이터를 읽을 때 사용하는 신호선
- 메모리 쓰기(Memory Write): CPU가 데이터를 메모리에 기록할 때 사용하는 신호선
- I/O 읽기(I/O Read): CPU가 입출력 장치에서 데이터를 읽을 때 사용하는 신호선
- I/O 쓰기(I/O Write): CPU가 데이터를 입출력 장치에 보낼 때 사용하는 신호선
- 인터럽트 요청(Interrupt Request): 하드웨어 장치가 CPU에 인터럽트를 요청할 때 사용하는 신호선
- 인터럽트 승인(Interrupt Acknowledge): CPU가 인터럽트 요청을 수락하고 처리할 때 사용하는 신호선
- 버스 요청(Bus Request): DMA 같은 장치가 시스템 버스를 사용하려고 요청할 때 사용하는 신호선
- 버스 승인(Bus Grant): CPU가 버스 요청을 승인해 DMA 장치가 버스를 사용할 수 있도록 할 때 사용하는 신호선
- 클락 신호(Clock Signal): 시스템의 동기화를 위한 신호선
- 리셋 신호(Reset): 시스템을 초기화할 때 사용하는 신호선

## BIOS, UEFI, 부트로더

BIOS (Basic Input/Output System):

- BIOS는 컴퓨터를 켤 때 가장 먼저 실행되는 펌웨어로, 하드웨어 초기화와 운영체제를 로드하는 역할을 한다.
- 하드웨어와 운영체제 사이에서 통신을 중재하며, 하드웨어 테스트(POST: Power-On Self-Test)를 한다.
- BIOS는 ROM에 저장된 코드로, 기본적으로 키보드, 모니터, 하드 드라이브 등의 하드웨어를 제어한다.

UEFI (Unified Extensible Firmware Interface):

- UEFI는 BIOS의 후속 기술로, 더 많은 기능과 빠른 부팅 속도를 제공한다.
- 그래픽 기반의 인터페이스와 보안 기능(Secure Boot)을 포함하며, 더 큰 하드 드라이브(2TB 이상의 드라이브)를 지원한다.
- UEFI는 운영체제와 하드웨어 간의 더 효율적인 인터페이스를 제공하며, 네트워크 기능이나 마우스 사용 등 고급 기능을 지원한다.

부트로더 (Bootloader):

- 부트로더는 BIOS나 UEFI가 하드웨어 초기화를 마친 후, 운영체제를 로드하는 프로그램이다.
- 컴퓨터가 켜지면 부트로더가 운영체제를 메모리에 올리고 실행하는 역할을 한다.
- 대표적인 부트로더로는 리눅스에서 많이 사용하는 GRUB, 윈도우의 Windows Boot Manager 등이 있다.

## 커널 vs 하이퍼바이저

![img](hypervisor.png)

| 특징        | 커널                                                                                         | 하이퍼바이저                                                    |
| ----------- | -------------------------------------------------------------------------------------------- | --------------------------------------------------------------- |
| 정의        | 운영 체제의 핵심 구성 요소로, 하드웨어 자원과 소프트웨어 간의 상호작용을 관리하는 소프트웨어 | 여러 가상 머신(VM)을 생성하고 관리하는 소프트웨어               |
| 주 목적     | 프로세스 관리, 메모리 관리, 파일 시스템 관리 등 운영 체제 기능 제공                          | 가상화, 자원 할당, 여러 운영 체제의 동시 실행 지원              |
| 자원 관리   | CPU, 메모리, I/O 장치 등 물리적 자원 관리                                                    | 물리적 자원을 가상 머신에 할당하고 관리                         |
| 문맥 교환   | 프로세스 간의 문맥 교환 관리                                                                 | 가상 머신 간의 문맥 교환 관리                                   |
| 의존성      | 하드웨어 위에서 직접 실행                                                                    | 하드웨어 위에서 또는 운영 체제 위의 가상화 계층으로 실행        |
| 형태        | 일반적으로 단일 커널 (자주 사용하는 구조)                                                    | 타입 1 하이퍼바이저(베어 메탈) 및 타입 2 하이퍼바이저(호스트형) |
| 설치 위치   | 물리적 하드웨어와 직접적으로 연결                                                            | 물리적 하드웨어 위에서 또는 운영 체제 내에서 간접적으로 실행    |
| 가상화 지원 | 기본적으로 가상화를 지원하지 않으며, 이를 위해 추가 소프트웨어가 필요                        | 기본적으로 가상화를 지원하며 여러 운영 체제를 동시에 실행 가능  |

## 시스템 호출과 비시스템 호출 구분해보기

### 시스템 호출 (System Call)

시스템 호출은 운영 체제의 기능을 직접 호출하는 것이며, 주로 파일 시스템, 네트워크, 프로세스 관리 등과 관련된 작업을 수행한다.

- `fs.readFile()`: 파일을 읽기 위한 시스템 호출
- `fs.writeFile()`: 파일에 쓰기 위한 시스템 호출
- `http.createServer()`: HTTP 서버를 생성하는 시스템 호출
- `net.createServer()`: TCP 서버를 생성하는 시스템 호출
- `child_process.exec()`: 자식 프로세스를 생성하는 시스템 호출

### 비시스템 호출 (Non-System Call)

비시스템 호출은 운영 체제와 직접적으로 상호작용하지 않는 코드로, 주로 메모리 내에서 데이터 처리나 계산을 수행한다.

- 숫자 계산, 문자열 조작 등
- 배열, 객체 등을 사용한 데이터 처리
- Promise 및 async/await를 사용한 비동기 처리, 시스템 자원에 의존하지 않는 경우

## 애플리케이션이 메모리를 할당받는 과정

고급 언어로 작성된 애플리케이션은 런타임 환경(Node.js, JVM, Python)을 통해 메모리를 할당받고, 런타임 환경은 운영체제에게 메모리를 할당받는 구조를 갖는다.

## 프로세스와 스레드의 가장 큰 차이점

- 프로세스와 스레드는 모두 문맥 스위칭을 통해 CPU에서 수행되지만, 프로세스는 각자의 독립적인 메모리 공간을 유지한다.
- 프로세스는 자원을 독립적으로 소유하고 안전성을 높이지만, 스레드는 동일한 자원을 공유하여 효율적인 통신과 자원 접근이 가능하다.
