---
updatedAt: 2024-04-21
directory: Design
fileName: Frontend
title: 프론트엔드 설계 톺아보기
description:
---

# Frontend Design

- [프로젝트 환경 설정 체크리스트](#프로젝트-환경-설정-체크리스트)
- [설계 목록](#설계-목록)
- [데이터 핸들링](#데이터-핸들링)
- [그림으로 보는 프론트엔드 설계](#그림으로-보는-프론트엔드-설계)
- [유효성 설계](#유효성-설계)
- [페이지 간 데이터 전달](#페이지-간-데이터-전달)
- [하나의 페이지를 미들웨어(인터셉터) 처럼 사용해서 값에 따라 페이징 분기처리 하는 방법](#하나의-페이지를-미들웨어인터셉터-처럼-사용해서-값에-따라-페이징-분기처리-하는-방법)
- [프로덕션 배포](#프로덕션-배포)
- [오래 걸리는 로직](#오래-걸리는-로직)
- [ENUM 관리](#enum-관리)
- [입력 구분](#입력-구분)
- [axios 요청 응답 타입 인터페이스 정의](#axios-요청-응답-타입-인터페이스-정의)
- [로그인 설계](#로그인-설계)

## 프로젝트 환경 설정 체크리스트

- repository structure
  - [ ] monorepo
  - [ ] multirepo
- rendering method
  - [ ] (CSR) react
  - [ ] (CSR + SSG + SSR) next
- mock data
  - [ ] express
  - [ ] next
  - [ ] nest
- [ ] eslint
- [ ] prettier
- [ ] tsconfig
- css framework
  - [ ] emotion
  - [ ] tailwind
- [ ] react-hook-form
- [ ] react-router
- global state managemet
  - [ ] recoil
  - [ ] redux
- asynchronous data management
  - [ ] react-query
  - [ ] redux-saga
- intl
  - [ ] react-intl
  - [ ] next-translate
- util
  - [ ] axios
  - [ ] lodash
  - [ ] qs
  - [ ] js-cookie
  - [ ] dayjs
  - [ ] moment
  - [ ] xlxs
  - [ ] uuid
  - [ ] jwt-decode
  - [ ] file-saver
- chart
  - [ ] chartjs
  - [ ] d3.js
- drag&drop
  - [ ] ...
- WYSIWYG
  - [ ] ...

## 설계 목록

- [ ] 레이아웃 설계
- [ ] 헤더, 푸터, 네비게이션 설계
- [ ] 페이지 설계
- [ ] 권한에 따른 라우트 가드 설계(미들웨어 방식)
- [ ] 비동기 통신 인터셉터 설계
- [ ] 로그인 토큰 제어 방법 설계
- [ ] 다국어 언어 데이터 구조 설계
- [ ] 디자인 컴포넌트 설계
- [ ] 데이터 컴포넌트 설계
- [ ] 검색, 정렬, 필터링, 페이징, 사이징 관련 쿼리 설계
- [ ] 클라이언트 데이터 관리 방법 설계
- [ ] 클라이언트 데이터 자료형 및 초기값 설정
- [ ] 클라이언트 데이터 에러 처리 설계
- [ ] 폼 데이터 관리 방법 설계
- [ ] 폼 데이터 자료형 및 초기값 설정
- [ ] 폼 유효성 검사 및 에러 처리 설계
- [ ] 비동기 데이터 관리 방법 설계
- [ ] 비동기 데이터 자료형 및 초기값 설정
- [ ] 비동기 데이터 로딩/성공/에러 처리 설계
- [ ] 배열 데이터 갯수 0개 화면 설계

## 데이터 핸들링

- 데이터 종류 및 관리 툴
  - global state(Recoil, Context API)
  - global data(Cookie, Local Storage, Session Storage)
  - asynchronous data(React Query)
  - form state(React Hook Form)
  - local state(useState, useMemo, Context API)
  - filter data(Query)

위 데이터를 다루면서 내가 느낀 점은 대부분의 데이터는 자료형과 초기값을 가지는 편이 좋다는 것이다. 그 이유는 하나의 변수가 다양한 자료형이 될 수 있거나, 초기값이 없다면 해당 변수를 자바스크립트 내부에서 사용할 때 예상치 못한 타입 에러가 날 가능성이 높고, 해당 상황은 사용자 경험을 저하시키기 떄문이다. 특히 특정 자료형에만 존재하는 메서드를 사용할 때 에러가 많이 발생하는데, 변수에 다른 자료형 값이 들어있다던지 `null`값이 들어있다면 메서드를 가지고 있지 않기 때문에 에러가 나게 된다. 이러한 실수들을 방지하기 위해 타입스크립트가 나오게 된 배경이 아닌가 싶다. 전 프로젝트에서 타입스크립트를 사용하다가 현재 프로젝트에서 타입스크립트를 사용하지 않다보니 크게 불편함을 많이 느꼈다.

클라이언트에서 다루는 데이터의 경우 대부분의 경우 `string` 형태의 자료형을 가진다. `string` 형태가 다른 `number`, `boolean` 형태보다 메서드도 많기 때문에 값을 다양하게 조작이 가능하다. 그래서 데이터의 자료형과 초기값은 기본적으로 `string` 형태의 빈 값을 세팅한 후, 작업을 하면서 자료형이 변경되어야 할 때 수정하면서 진행하는 편이 작업이 수월하다고 생각한다. 마치 `const`로 변수를 세팅한 후 변경이 필요한 값에 대해 `let`으로 수정하는 것과 비슷하다.

주로 필터는 리스트 목록에 대해 서버단에서 데이터를 불러올 때 사용되는데, 이는 쿼리를 이용해서 값을 관리한다. 그 이유는 새로고침 시에도 해당 필터를 그대로 적용하기 위함이 가장 큰 이유라고 생각한다. 물론, 이 방법말고도 다른 방법으로 필터를 관리할 수도 있지만 개인적인 생각으로는 쿼리를 사용한 방식이 가장 보편적이고 쉬운 방식이라고 생각한다.

히스토리에 스택을 남기면서 쿼리를 사용하면 뒤로가기 시 전에 클릭했던 필터 세팅으로 이동하게 되고, 히스토리에 스택을 남기지 않으면서 쿼리를 사용하면 뒤로가기 시 전 페이지로 이동하게 된다. 이는 요구사항에 맞게 구현하면 된다.

쿼리는 `?foo=a&bar=b`의 형식으로 작성이 되고, 이는 모두 문자열로 작성이 되어 서버로 보내진다. 그래서 클라이언트에서나 서버에서나 쿼리를 읽어들일 때는 적절한 자료형으로 파싱해서 사용해야 한다. 보통 `qs` 라이브러리를 이용해 손쉽게 해결할 수 있다.

모두 문자열이기 때문에 `null` 또는 `undefined`도 문자열로 인식하기 때문에 없는 값에 대한 데이터는 어떻게 전송해야하는지 백엔드와 협의하여 논의된 방식으로 전송하면 된다. 예를 들어 아예 보내지 않거나, 빈 문자열을 보내거나 아니면 문자열 `null`을 보내는 방식이 있다. 배열 같은 경우는 `?foo=1&foo=2` 또는 `?foo[]=1&foo[]=2` 등 `qs` 라이브러리에서 여러 형태의 포맷을 지원하며 백엔드와 협의하여 논의된 포맷으로 데이터를 전송하면 된다.

비동기 데이터의 경우 GET의 경우 로딩/성공/에러의 상태를 가지고 PUT/POST/DELETE의 경우 대기/로딩/성공/에러의 상태를 가지기 때문에 초기값을 작성하는 케이스보다 가짜 비동기 데이터를 보내주는 API를 작성하는 것이 좋다. 이유는 상태에 따른 대응을 할 수 있기 때문이다. 비동기 데이터는 `null` 또는 `undefined`로 오는 경우가 존재하므로 이 경우에는 옵셔널 체이닝(`.?`)과 nullish 연산자(`??`)를 이용해 해당 데이터가 `null`인지 체킹하고 `null`이면 초기값을 세팅해주는 방식을 사용하자.

> 비동기 데이터 제어 시 원본 데이터를 기반으로 새 데이터를 받는 식으로 가공해서 작성하는 것이 불변성 유지에 좋다

## 그림으로 보는 프론트엔드 설계

![frontend_design](assets/frontend_design.jpg)

## 유효성 설계

<!-- todo: 내용 보완 필요 -->

입력의 제한을 두는 것이 아닌 입력은 자유로우나 해당 입력이 잘못됐으면 사용자 경험상 UI로 표현해준다. 입력에 대한 에러가 존재하면 그 입력값을 요청값으로 보내는 API는 동작하지 않도록 설계한다. 유효성 검사 로직과 API 요청 로직은 분리해서 작성한다.

## 페이지 간 데이터 전달

<!-- todo: 내용 보완 필요 -->

## 하나의 페이지를 미들웨어(인터셉터) 처럼 사용해서 값에 따라 페이징 분기처리 하는 방법

<!-- todo: 내용 보완 필요 -->

## 프로덕션 배포

<!-- todo: 내용 보완 필요 -->

React는 빌드 시 정적 자산을 생성하고 웹 서버를 통해 해당 정적 자산을 브라우저에 보내는 방식으로 배포를 한다. 단, 빌드 시 생성하는 정적 자산마다 이름이 같으면 캐시되어 브라우저에서 새로고침을 해도 업데이트가 안되기 때문에 빌드 시 마다 다른 이름의 정적 자산이 생기도록 설정이 필요하다.

Next도 빌드 시 정적 자산을 생성하고 업데이트를 반영하기 위해서는 서버를 재시작해야 한다. 그리고 브라우저에서 새로고침을 하면 업데이트가 반영된다.

## 오래 걸리는 로직

데이터가 결합된 보고서 대량 파일 다운로드

1. 사용자가 요청을 하면 작업이 완료된 후 사용자에게 이메일 전송을 한다. 이후 사용자는 파일을 다운로드 받는다.
2. 프로젝트 종료 시에 데이터가 결합된 보고서를 미리 생성하고, 이후 사용자가 요청하면 생성된 보고서를 제공한다.
3. 요청 시에 보고서를 만들어서 제공한다.(요청 시간 매우 김, 비효율)

## ENUM 관리

- Select용 key, Radio용 key
- 정렬용 key
- 상태용 key

## 입력 구분

- 미입력 상태와 입력 상태 구분되야함
  기본값이 입력 상태일 수도, 미입력 상태일 수도
  필수값은 입력이 있어야하고
  선택값은 입력이 없어도된다
  미입력 시 서버에 null or undefined로 전송
  입력 값만 전송

## axios 요청 응답 타입 인터페이스 정의

- 응답은 모두 누락되거나 null될 가능성이 있으므로 옵셔널 필드와 null 처리를 해줌
- 요청값은 필수값, 선택값을 구분하여 옵셔널 필드 처리만 해줌

## 로그인 설계

react, nextjs 구분 지어서 라우팅 방법 작성

로그인 시 라우팅

미들웨어를 이용한 라우팅 가드

로그아웃 토큰 제거

axios 인터셉터를 이용한 인증 만료된 토큰 처리

보안적인 측면에서는, 개인정보 같은 데이터는 인증된 사용자에 한해서는 브라우저에 존재해도 된다고 생각한다.

웹 스토리지, 쿠키는 모두 인증된 사용자에 한해서 데이터가 저장된다는 생각을 기반으로 설계된 놈들이기에 암호화 기능이 없다.

그러므로 해당 스토리지들에는 인증이 끝난 사용자에 한해서는 데이터가 저장되서는 안된다.

session storage를 이용하는 것이 권장된다. 브라우저가 종료되면 데이터가 휘발되기 떄문에

자동 로그인 같은 경우 사용자의 동의를 받고 데이터가 노출될 수 있음을 알려야 한다.

자동 로그인 트렌드는 본인이 신뢰할 수 있는 기기인지를 등록하여 사용하게 된다.

ui 제어로 보안 불가능 개발자 도구에서 얼마든지 뚫을 수 있음, disabled -> enabled

권한

동시 접속 제한
