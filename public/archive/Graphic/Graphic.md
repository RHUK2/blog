---
updatedAt: 2024-03-20
directory: Graphic
fileName: Graphic
title: Graphic 기록하기
description:
---

# chartjs

캔버스 렌더링
Chart.js는 SVG로 렌더링하는 다른 여러 차트 라이브러리(대부분 D3.js 기반)와 달리 HTML5 캔버스에서 차트 요소를 렌더링합니다. 캔버스 렌더링은 특히 대규모 데이터 세트와 DOM 트리에 수천 개의 SVG 노드가 필요한 복잡한 시각화에서 Chart.js의 성능을 매우 향상시킵니다. 동시에 캔버스 렌더링은 CSS 스타일링을 허용하지 않으므로 기본 제공 옵션을 사용하거나 사용자 정의 플러그인 또는 차트 유형을 만들어 모든 것을 원하는 대로 렌더링해야 합니다.

#성능
Chart.js는 대규모 데이터 세트에 매우 적합합니다. 이러한 데이터 세트는 내부 형식을 사용하여 효율적으로 수집할 수 있으므로 데이터 구문 분석 및 정규화를 생략할 수 있습니다. 또는 데이터 데시메이션을 구성하여 데이터 집합을 샘플링하고 렌더링하기 전에 크기를 줄일 수 있습니다.

결국, Chart.js가 사용하는 캔버스 렌더링은 SVG 렌더링에 비해 DOM 트리에 대한 부담을 줄여줍니다. 또한 트리 흔들기를 지원하므로 번들에 Chart.js 코드의 최소 부분을 포함할 수 있으므로 번들 크기와 페이지 로드 시간이 줄어듭니다.

# d3.js

D3는 유연합니다.
D3에는 중요한 '차트' 추상화가 없기 때문에 기본 차트에도 수십 줄의 코드가 필요할 수 있습니다. 장점은 모든 요소가 눈앞에 펼쳐져 있고 사용자가 모든 것을 완벽하게 제어할 수 있다는 점입니다. 원하는 것을 정확히 달성하도록 비주얼리제이션을 조정할 수 있습니다. D3에는 데이터에 대한 기본 프레젠테이션이 없으며 사용자가 직접 작성하는 코드만 있습니다. (또는 예제에서 복사할 수도 있습니다.)

D3는 고급 차트 라이브러리의 대안이 아니라 '모든 것을 직접 하는 것'의 대안이라고 생각하세요. 다른 도구에 만족하지 않고 SVG나 캔버스(또는 WebGL)를 사용하여 자신만의 차트를 만들 생각이라면 D3의 도구 상자를 살펴보는 것도 좋습니다! 창의력을 제한하지 않으면서도 원하는 차트를 만드는 데 도움이 되는 도구가 분명히 있을 것입니다.

웹에서 작동하는 D3
D3는 새로운 그래픽 표현을 도입하는 것이 아니라 SVG 및 Canvas와 같은 웹 표준에서 직접 D3를 사용합니다.

'D3'라는 이름은 데이터 기반 문서의 약자로, 여기서 문서는 웹페이지의 콘텐츠를 나타내는 DOM(문서 객체 모델) 표준을 의미합니다. D3의 일부 모듈(예: 선택 및 전환)은 DOM에 영향을 주지만, 다른 모듈(스케일 및 도형 포함)은 데이터에 대해서만 작동합니다. D3는 React, Vue, Svelte와 같은 웹 프레임워크와도 함께 사용할 수 있으며, 권장 사항은 시작 가이드를 참조하세요.

D3가 웹 표준을 수용하면 많은 이점이 있습니다. 예를 들어, 외부 스타일시트를 사용하여 차트의 모양을 변경할 수 있고(반응형 차트나 다크 모드와 같은 미디어 쿼리에 대한 응답에서도), 디버거와 요소 검사기를 사용하여 코드가 수행하는 작업을 검토할 수 있으며, D3의 동기식 필수 평가 모델(selection.attr을 호출하면 즉시 DOM을 변경)을 사용하면 복잡한 비동기 런타임을 가진 프레임워크보다 디버깅이 더 쉬워집니다.

맞춤형 비주얼라이제이션을 위한 D3
D3는 모든 것을 가능케 하지만 반드시 쉬운 것은 아닙니다. 쉬워야 할 간단한 작업도 그렇지 않은 경우가 많습니다. 아만다 콕스의 말을 빌리자면, "막대형 차트에 100줄의 코드를 작성하는 것이 지극히 정상적이라고 생각한다면 D3를 사용하세요."

맞춤형 비주얼리제이션에 최대한의 표현력이 필요하다면 D3를 고려해야 합니다. D3는 하나의 그래픽을 백만 명의 독자가 볼 수 있고 편집자 팀이 협력하여 시각적 커뮤니케이션의 최신 기술을 발전시킬 수 있는 The New York Times 또는 The Pudding과 같은 미디어 조직에 적합합니다.

반면에 D3는 개인 대시보드나 일회성 분석에 사용하기에는 과분합니다. 위즈뱅 예시에 현혹되지 마세요. 많은 예시들이 구현하는 데 엄청난 노력이 필요했습니다! 시간에 제약이 있다면(그렇지 않은 사람이 어디 있겠습니까?) 관찰 가능한 플롯으로 더 나은 시각화 또는 분석을 만들 수 있을 것입니다.

동적 시각화를 위한 D3
D3의 가장 새로운 개념은 데이터 조인입니다. 데이터 집합과 DOM 요소 집합이 주어지면 데이터 조인을 통해 요소를 입력, 업데이트 및 종료하기 위한 별도의 작업을 적용할 수 있습니다. 정적 차트(애니메이션이 적용되거나 사용자 입력에 반응하지 않는 차트)만 만드는 경우 이 개념이 직관적이지 않거나 심지어는 필요하지 않다고 느낄 수도 있습니다.

데이터 조인은 데이터가 변경될 때 발생하는 상황을 정확히 제어하고 그에 따라 디스플레이를 업데이트할 수 있도록 존재합니다. 이러한 직접 제어를 통해 DOM을 변경하지 않고도 변경이 필요한 요소와 속성만 터치하면 매우 뛰어난 성능의 업데이트와 상태 간 부드러운 애니메이션 전환이 가능합니다. D3는 동적인 대화형 시각화에서 빛을 발합니다. (2012년에 출시된 '512개의 경로로 백악관으로 가는 길'에서 상태 토글을 옵션으로 클릭해 보세요. 정말 멋집니다.)

# svg vs canvas

아래 표는 Canvas와 SVG의 주요 특성들을 한 곳에 모아 정리한 것입니다.

| 특성             | Canvas                                                                         | SVG                                                        |
| ---------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------- |
| 렌더링 방식      | 비트맵 (픽셀)                                                                  | 벡터 (XML 기반)                                            |
| 그리기 방식      | JavaScript 코드를 사용하여 프로그래밍적 그리기                                 | 마크업 언어 (HTML과 유사한 방식)                           |
| 확장성           | 화면 크기에 따라 그래픽이 자동으로 조정되지 않음                               | 확대/축소시 해상도 손상 없음                               |
| 인터랙티브 기능  | 주로 정적 그래픽에 사용되며, JavaScript 이벤트 처리를 사용하여 인터랙션을 추가 | 마크업 언어로 인터랙티브 요소를 직접 포함                  |
| 복잡성           | 프로그래밍적으로 그림을 그리므로 복잡한 그래픽 또는 애니메이션에 적합          | XML 기반의 마크업 언어로 간단한 그래픽을 표현할 때 적합    |
| 이미지 지원      | 이미지를 그리기 위한 내장 메서드가 제공되지 않음                               | `<image>` 요소를 통해 외부 이미지를 삽입 가능              |
| 텍스트 처리      | 텍스트를 그리는 데 제한적이며, 복잡한 텍스트 렌더링에 적합하지 않음            | 텍스트를 마크업 언어로 처리하므로 텍스트 렌더링에 적합     |
| 애니메이션 지원  | 주로 JavaScript를 사용하여 애니메이션을 구현                                   | `<animate>` 요소를 사용하여 애니메이션을 구현              |
| 성능             | 복잡한 그래픽이 많을 때 더 빠른 렌더링 속도를 제공할 수 있음                   | 복잡한 그래픽의 경우 렌더링 속도가 상대적으로 느릴 수 있음 |
| 스타일링 및 효과 | CSS를 사용할 수 없으며, 스타일링과 효과를 JavaScript로 직접 처리해야 함        | CSS를 사용하여 스타일링 및 효과를 적용할 수 있음           |
| 브라우저 호환성  | 대부분의 모던 브라우저에서 지원됨                                              | 일부 구형 브라우저에서는 지원되지 않을 수 있음             |
| 파일 크기        | 이미지 파일로 저장할 때 상대적으로 작은 파일 크기를 가짐                       | XML 기반의 마크업으로 인해 파일 크기가 증가할 수 있음      |
| 접근성           | 그래픽 요소에 대한 접근성이 상대적으로 낮을 수 있음                            | 마크업 언어를 사용하여 접근성을 개선할 수 있음             |

이 표를 참고하여 Canvas와 SVG의 주요 특성을 비교 분석할 수 있습니다.

#

Node.js에서 SVG 작업을 수행하는 방법은 Canvas 작업을 수행하는 방법과 다릅니다. SVG 작업에 있어서는 외부 라이브러리를 사용할 수도 있지만, SVG 파일을 직접 생성하고 조작하는 데는 별도의 의존성이 필요하지 않습니다. 다음은 그 차이점과 각각의 방법에 대한 설명입니다:

### SVG 작업

#### 1. **SVG 직접 처리**

- **XML 기반 포맷**:
  SVG는 XML 기반의 벡터 그래픽 포맷으로, 텍스트 형식으로 정의됩니다. 즉, SVG 파일을 생성하거나 조작하는 것은 XML 문서를 작성하는 것과 유사합니다.
- **자바스크립트로 직접 작성**:
  자바스크립트에서는 SVG XML 문자열을 직접 생성할 수 있습니다. 이는 외부 라이브러리 없이 XML 형식으로 SVG 요소를 직접 작성하고 조작할 수 있음을 의미합니다.

  ```javascript
  const fs = require('fs');

  const svgContent = `
    <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
      <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
    </svg>
  `;

  fs.writeFileSync('example.svg', svgContent);
  ```

  위 코드는 XML 문자열을 직접 작성하여 SVG 파일을 생성하는 예시입니다. 외부 라이브러리 없이 SVG를 직접 생성할 수 있습니다.

#### 2. **외부 라이브러리 사용**

- **라이브러리의 장점**:
  외부 라이브러리를 사용하면, SVG 문서를 보다 효율적으로 생성하고 조작할 수 있습니다. 라이브러리는 다양한 SVG 요소와 속성을 추상화하여, 복잡한 SVG 구조를 손쉽게 처리할 수 있게 도와줍니다.

  예를 들어, `svg.js` 같은 라이브러리를 사용하면 자바스크립트 API를 통해 SVG 요소를 동적으로 생성하고 조작할 수 있습니다.

  ```javascript
  const { SVG } = require('@svgdotjs/svg.js');
  const fs = require('fs');

  const draw = SVG().size(100, 100);
  draw.circle(80).center(50, 50).fill('red').stroke({ color: 'black', width: 3 });

  fs.writeFileSync('example.svg', draw.svg());
  ```

  위 코드는 `@svgdotjs/svg.js` 라이브러리를 사용하여 SVG 문서를 생성하고 파일로 저장하는 예시입니다.

### Canvas 작업

- **외부 라이브러리 의존성**:
  `node-canvas`와 같은 Canvas 라이브러리는 C++로 작성된 Cairo 그래픽 라이브러리를 기반으로 하며, Node.js에서 2D 그래픽 작업을 지원하기 위해 네이티브 애드온을 사용합니다. 이 라이브러리는 고급 그래픽 처리를 위해 별도의 네이티브 라이브러리에 의존합니다.

  ```javascript
  const { createCanvas } = require('canvas');
  const fs = require('fs');

  const canvas = createCanvas(200, 200);
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = 'blue';
  ctx.fillRect(10, 10, 100, 100);

  const buffer = canvas.toBuffer('image/png');
  fs.writeFileSync('example.png', buffer);
  ```

  위 코드는 `node-canvas` 라이브러리를 사용하여 2D 그래픽을 생성하고 PNG 이미지 파일로 저장하는 예시입니다. `node-canvas`는 네이티브 애드온에 의존하므로, 별도의 설치 및 설정이 필요합니다.

### 요약

- **SVG 작업**: 자바스크립트로 직접 XML 문자열을 작성하여 SVG 파일을 생성할 수 있으며, 외부 라이브러리는 선택적입니다. 라이브러리를 사용하면 SVG 작업이 더 쉬워지고 기능이 확장됩니다.
- **Canvas 작업**: Node.js에서 Canvas 작업을 수행하려면 `node-canvas`와 같은 외부 라이브러리에 의존합니다. 이는 네이티브 애드온을 통해 2D 그래픽 작업을 지원합니다.

결론적으로, SVG 작업은 기본적으로 자바스크립트로 직접 처리할 수 있지만, 더 복잡한 작업을 원하거나 더 편리한 API를 원할 경우 외부 라이브러리를 사용할 수 있습니다. 반면, Canvas 작업은 기본적으로 외부 라이브러리에 의존하여야 합니다.

#

Node.js 자체는 기본적으로 그래픽 작업을 지원하지 않지만, 외부 라이브러리들은 다양한 원리와 기술을 활용하여 Node.js에서 그래픽 작업을 수행할 수 있도록 지원합니다. 이러한 라이브러리들은 Node.js의 한계를 넘어 그래픽 처리 작업을 수행할 수 있게 해주며, 주로 다음과 같은 원리를 사용합니다:

### 1. **Canvas 라이브러리**

#### `node-canvas`의 원리

1. **Cairo 그래픽 라이브러리**:

   - `node-canvas`는 C로 작성된 Cairo 그래픽 라이브러리를 활용하여 2D 그래픽을 처리합니다. Cairo는 고급 2D 그래픽 라이브러리로, 벡터 그래픽과 비트맵 그래픽을 지원합니다.
   - Node.js에서 `node-canvas`는 Cairo를 C++ 애드온으로 래핑하여 자바스크립트와 상호작용할 수 있게 합니다. 이를 통해 Canvas API를 자바스크립트에서 사용할 수 있습니다.

2. **네이티브 애드온**:

   - `node-canvas`는 Node.js의 네이티브 애드온 기능을 사용합니다. 이는 C++로 작성된 코드를 Node.js에서 호출할 수 있게 해주는 기능으로, 그래픽 처리와 같은 성능이 중요한 작업에 사용됩니다.
   - 이 네이티브 애드온은 Node.js에서 JavaScript와 네이티브 코드를 효율적으로 통신하게 해줍니다.

3. **랜더링**:
   - `node-canvas`는 Canvas API를 제공하여, 사용자가 자바스크립트로 2D 그래픽을 그릴 수 있게 합니다. 이 API는 내부적으로 Cairo 라이브러리를 사용하여 실제 그래픽 작업을 수행합니다.

### 2. **SVG 라이브러리**

#### `svg.js`와 같은 라이브러리의 원리

1. **자바스크립트로 SVG 생성**:

   - `svg.js`와 같은 라이브러리는 자바스크립트로 SVG 문서를 생성하고 조작할 수 있는 API를 제공합니다.
   - SVG는 XML 기반의 포맷으로, 이들 라이브러리는 자바스크립트 객체 모델을 사용하여 SVG 요소를 생성하고, XML 문자열로 변환합니다.

2. **내부 XML 처리**:

   - 이러한 라이브러리들은 SVG 문서를 구성하는 XML 구조를 자바스크립트 객체로 모델링합니다. 사용자는 이 객체를 조작하여 SVG 문서를 만들거나 수정할 수 있습니다.
   - 최종적으로, 생성된 SVG XML을 문자열로 변환하여 파일로 저장하거나 다른 작업에 사용할 수 있습니다.

3. **클라이언트와 서버 간의 변환**:
   - SVG 라이브러리는 서버 측에서 SVG 데이터를 생성한 후, 이를 클라이언트에서 사용하거나 파일로 저장할 수 있도록 합니다. 이는 웹 브라우저에서도 사용 가능한 SVG 포맷을 생성하기 위한 것입니다.

### 3. **성능 최적화와 지원**

1. **성능 최적화**:

   - 네이티브 라이브러리는 C++로 작성된 코드로, JavaScript보다 성능이 뛰어나므로 대량의 그래픽 작업을 빠르게 처리할 수 있습니다.
   - 이러한 네이티브 애드온은 그래픽 작업에서 성능을 극대화하기 위해 최적화된 알고리즘과 데이터 구조를 사용합니다.

2. **파일 시스템과의 상호작용**:
   - Node.js는 파일 시스템 모듈(`fs`)을 통해 생성된 이미지 파일을 디스크에 저장하거나 불러오는 작업을 지원합니다.
   - Canvas 및 SVG 라이브러리들은 이러한 Node.js의 파일 시스템 API와 통합되어, 생성된 그래픽을 파일로 저장하거나 네트워크를 통해 전송하는 등의 작업을 지원합니다.

### 요약

- **Canvas 라이브러리 (`node-canvas`)**: C++로 작성된 Cairo 그래픽 라이브러리를 사용하는 네이티브 애드온을 통해 2D 그래픽 작업을 처리합니다.
- **SVG 라이브러리 (`svg.js` 등)**: 자바스크립트를 사용하여 SVG 문서를 생성하고 조작하며, XML 기반의 벡터 그래픽을 처리합니다.

이 외부 라이브러리들은 Node.js의 비그래픽적인 기본 기능 위에 그래픽 처리를 위한 강력한 기능을 추가하여, 서버 측에서도 그래픽 작업을 효과적으로 수행할 수 있게 해줍니다.
