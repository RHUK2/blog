---
updatedAt: 2024-03-11
directory: NextJS
fileName: NextJS
title: NextJS 기록하기
description:
---

# NextJS

- [NextJS](#nextjs)
  - [렌더링 전략 4가지](#렌더링-전략-4가지)
    - [SSG](#ssg)
    - [CSR](#csr)
    - [ISR](#isr)
    - [SSR](#ssr)
  - [hydration](#hydration)
  - [웹 성능 지표](#웹-성능-지표)
  - [코드스플리팅, 프리렌더링](#코드스플리팅-프리렌더링)

## 렌더링 전략 4가지

![compare_rendering](https://onedrive.live.com/embed?resid=7DCB8F9953BAAF94%217106&authkey=%21AGBjZT-fCNEb1ME&width=1920&height=2200)

### SSG

- 1단계: Next.js는 서버에서 `.css` 및 `.js`와 함께 단일 페이지 앱을 `.html` 파일로 생성한다. 사전 렌더링이라고 하는 이 단계는 빌드 시점에 한 번만 수행된다. 이 단계에서 모든 페이지(HTML)가 생성되는데, 여기에는 React 코드, CSS, JavaScript, 그리고 페이지가 `getStaticProps()`와 같은 데이터 불러오기 메서드를 사용하는 경우 선택적으로 데이터도 포함된다.
- 2단계: 클라이언트가 CDN에 싱글 페이지 앱을 요청합니다.
- 3단계: 클라이언트가 CDN에서 싱글 페이지 앱을 다운로드합니다.
- 4단계: 클라이언트가 싱글 페이지 앱을 파싱하여 브라우저에 렌더링한다. 페이지의 HTML이 서버 측에서 미리 렌더링되어 있으므로 클라이언트 브라우저는 이를 그대로 로드하고 렌더링하기만 하면 된다. 또한 페이지가 최소한의 자바스크립트 코드로 브라우저에서 렌더링할 수 있는 방식으로 코딩되어 있기 때문에 렌더링 차단이 최소로 줄어들어 성능 결과가 우수하다.
- 5단계: React (자바스크립트) 코드를 실행하여 페이지를 (재)하이드레이트합니다. 페이지가 미리 빌드되었더라도 이 추가 단계는 React가 JavaScript 이벤트를 가상 DOM에 첨부하거나 활성화하고 페이지를 대화형으로 만들 수 있도록 하기 위해 필요합니다. 이 시점에서 자바스크립트가 실행되므로 총 차단 시간은 이 추가 단계의 영향을 받습니다. 또한 브라우저는 수화 프로세스가 완료될 때까지 기다려야 하므로 인터랙티브 시간도 영향을 받습니다.

### CSR

- 1단계: 콘텐츠(데이터)가 미리 렌더링되지 않거나 정적 묶음에 포함되지 않는다는 점을 제외하면 SSG의 1단계와 동일하다. 따라서 파일 크기가 작아져 다운로드 시간이 단축된다.
- 2단계: SSG의 2단계와 동일하지만 콘텐츠(데이터)가 없다.
- 3단계: SSG의 3단계와 동일하지만 콘텐츠(데이터)가 없다.
- 4단계: SSG의 4단계와 동일하다.
- 5단계: SSG의 5단계와 동일하지만 콘텐츠(데이터)가 없다.
- 6단계: 클라이언트가 콘텐츠(데이터)를 가져오고 React가 UI를 업데이트한다.

### ISR

- 1단계: SSG의 1단계와 동일합니다.
- 2단계: 클라이언트가 CDN에 싱글 페이지 앱을 요청합니다. 또한 페이지가 재검증 옵션과 함께 데이터 가져오기 메서드 getStaticProps()를 사용하는 경우 가져오기 결과에서 반환된 데이터가 업데이트된 경우 페이지가 다시 생성됩니다. 1,000페이지가 넘는 대규모 사이트에는 이 메서드를 사용할 것을 권장합니다. 각 페이지를 미리 렌더링하는 데 시간이 걸리므로 이 증분 방식을 사용하면 첫 번째 요청과 페이지 콘텐츠가 업데이트될 때만 미리 렌더링됩니다.
- 3단계: SSG의 3단계와 동일합니다.
- 4단계: SSG의 4단계와 동일합니다.
- 5단계: SSG의 5단계와 동일합니다.
-

### SSR

- 1단계: Next.js가 페이지를 생성(미리 렌더링)하지 않습니다.
- 2단계: 클라이언트가 서버에 단일 페이지 앱을 요청합니다. Next.js는 서버에서 .css 및 .js와 함께 단일 페이지 앱을 .html 파일로 생성(사전 렌더링)합니다. 이 단계에서 React 코드, CSS, JavaScript 및 페이지가 getServerSideProps() 데이터 불러오기 메서드를 사용하는 경우 선택적으로 데이터를 포함한 모든 페이지 코딩(HTML)이 생성됩니다.
- 3단계: 클라이언트가 서버에서 싱글 페이지 앱을 다운로드합니다.
- 4단계: SSG의 4단계와 동일합니다.
- 5단계: SSG의 5단계와 동일합니다.

## hydration

hydration은 Next.js 프레임워크에서 사용되는 용어이다. 이 용어는 클라이언트 측에서 서버에서 렌더링된 HTML을 가져와서 해당 HTML을 JavaScript로 변환하고 상호작용성을 추가하는 과정을 가리킨다.

Next.js는 서버 측 렌더링(SSR)과 클라이언트 측 렌더링(CSR)을 모두 지원한다. 서버 측 렌더링은 요청 시에 서버에서 페이지를 렌더링하고 완전한 HTML을 클라이언트에 반환한다. 이러한 방식으로 앱의 초기 로드 시간을 줄일 수 있고, SEO를 향상시킬 수 있다. 그러나 이렇게 생성된 페이지는 정적이며, 사용자와의 상호작용에는 제한이 있다.

클라이언트 측 렌더링은 페이지를 브라우저에서 JavaScript를 사용하여 렌더링하는 방식입니다. 이것은 앱의 상호작용성을 높일 수 있지만, 초기 로드 시간이 길어질 수 있으며, SEO에도 부정적인 영향을 줄 수 있습니다.

Next.js에서는 이 두 가지 방법을 결합하여 최상의 사용자 경험을 제공하기 위해 "hydration"이라는 개념을 도입했습니다. 이것은 서버 측에서 렌더링된 페이지의 HTML이 클라이언트로 전송되고, 클라이언트에서 해당 HTML을 가져와서 JavaScript를 사용하여 적절한 상호작용성을 추가하는 프로세스입니다. 이를 통해 초기 로드 시간을 최소화하고, 사용자가 페이지를 빠르게 볼 수 있게 됩니다. 이 과정을 "hydration"이라고 합니다.

결론적으로, Next.js의 hydration은 서버 측 렌더링과 클라이언트 측 렌더링의 장점을 결합하여 최상의 성능과 사용자 경험을 제공하는 데 도움이 됩니다.

## 웹 성능 지표

| 성능 지표                        | 설명                                                                                                          |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| FCP (First Contentful Paint)     | 페이지의 첫 번째 콘텐츠 요소가 화면에 렌더링되는 시간을 측정합니다.                                           |
| FMP (First Meaningful Paint)     | 페이지가 로드된 후 사용자가 유용한 콘텐츠를 볼 수 있는 시간을 측정합니다.                                     |
| TTI (Time to Interactive)        | 페이지가 로드된 후 사용자가 상호 작용할 수 있는 상태가 되는 시간을 측정합니다.                                |
| TTFP (Total Time to First Paint) | 페이지가 요청되어부터 브라우저가 첫 번째 픽셀을 그리는 데 걸리는 전체 시간을 측정합니다.                      |
| TBT (Total Blocking Time)        | 페이지 로드 중에 메인 스레드가 블록되는 시간의 합계를 측정합니다.                                             |
| LCP (Largest Contentful Paint)   | 페이지의 가장 큰 컨텐츠 요소가 화면에 렌더링되는 시간을 측정합니다.                                           |
| FID (First Input Delay)          | 사용자가 페이지와 상호 작용하기 시작한 후에 브라우저가 해당 상호 작용에 응답하는 데 걸리는 시간을 측정합니다. |
| CLS (Cumulative Layout Shift)    | 페이지가 로드되는 동안 발생하는 레이아웃의 예기치 않은 변화를 측정합니다.                                     |

## 코드스플리팅, 프리렌더링

리액트는 초기 html 파일이 빈 파일로 오고, nextjs의 ssg 전략은 처음 접속한 페이지의 html을 제공하고 이후 페이지가 변경될 때에는 자바스크립트만 변경되는거지? 이런 경우에도 SEO는 문제가 없는거고?

ChatGPT
올바른 지적이시네요. 네, 맞습니다! 리액트의 경우 초기 HTML 파일은 빈 상태로 제공되며, 이후에 자바스크립트가 로드되고 실행되면서 페이지가 렌더링됩니다. 반면에 Next.js의 SSG 전략은 초기에 방문한 페이지의 HTML을 미리 렌더링하여 제공하고, 이후에는 클라이언트 측에서 자바스크립트가 로드되고 페이지가 동적으로 변경됩니다.

빈 HTML을 제공하는 경우, 초기 로딩 속도는 느릴 수 있고, 검색 엔진은 페이지의 콘텐츠를 인식하기 어려울 수 있습니다. 그러나 Next.js의 SSG 전략을 사용하는 경우, 초기 로딩 시에는 이미 미리 렌더링된 HTML이 제공되므로 사용자는 빠르게 콘텐츠를 볼 수 있습니다. 이후에는 클라이언트 측에서 자바스크립트가 로드되어 페이지를 동적으로 변경할 수 있습니다.

이러한 동작 방식은 검색 엔진이 페이지의 콘텐츠를 더 잘 이해하고 인덱싱할 수 있도록 도와주며, 초기 로딩 속도를 향상시키므로 SEO에 유리합니다. 따라서 Next.js의 SSG 전략을 사용하는 경우에도 SEO에 문제가 없습니다.

User
페이지 변경 시에는 미리 렌더링된 html 파일을 주는 게 아니라 리액트처럼 새로 그리는거야?
ChatGPT
네, 맞습니다. 페이지 변경 시에는 Next.js에서도 일반적으로 React와 같이 클라이언트 측에서 새로 렌더링되는 것이 일반적입니다. 초기 페이지 요청 시에만 SSG(정적 사이트 생성)를 통해 미리 렌더링된 HTML 파일이 제공됩니다. 그 이후에는 클라이언트 측에서 JavaScript가 로드되고, React 컴포넌트가 렌더링되어 페이지가 업데이트됩니다.

다시 말해, 초기 요청 시에는 서버 측에서 해당 페이지의 HTML이 미리 렌더링되어 제공되지만, 사용자의 상호작용으로 인해 페이지가 변경되면 서버에서 새로운 HTML 파일을 생성하는 것이 아니라 클라이언트에서 React가 새로 렌더링됩니다.

이러한 방식은 초기 로딩 속도를 향상시키는 동시에 사용자 경험을 유지하면서도 동적으로 콘텐츠를 업데이트할 수 있게 해줍니다. SEO에도 이점을 제공합니다. 왜냐하면 검색 엔진은 초기 페이지 요청 시에 미리 렌더링된 HTML을 볼 수 있으며, 이는 초기 로딩 속도가 빠르고 콘텐츠가 잘 인덱싱되어 있는 것으로 해석될 수 있기 때문입니다.

User
아 ssg가 아니라 ssr이였어
ChatGPT
알겠습니다! SSR(Server Side Rendering)를 사용하는 경우, 페이지 변경 시에도 서버에서 새로운 HTML 파일을 생성하여 클라이언트에 전송할 수 있습니다.

SSR을 사용하면 클라이언트가 페이지를 요청할 때마다 서버에서 해당 페이지를 렌더링하고 초기 HTML을 생성합니다. 따라서 페이지 변경이 발생하면 해당 페이지의 HTML이 서버에서 다시 렌더링되어 클라이언트에게 새로운 HTML이 전송됩니다.

이러한 방식으로 SSR을 사용하면 사용자에게 동적으로 업데이트된 콘텐츠를 제공할 수 있으며, 초기 로딩 속도가 빠르고 SEO에도 유리합니다. 사용자가 페이지를 요청할 때마다 서버에서 새로운 HTML을 생성하기 때문에 항상 최신 상태의 콘텐츠를 보여줄 수 있습니다.

따라서 SSR을 사용하면 페이지 변경 시에도 새로운 HTML 파일을 서버에서 제공할 수 있으며, 이는 초기에 요청한 HTML 파일이 아닌 새로 생성된 HTML 파일이 클라이언트에게 전송되는 것을 의미합니다.
