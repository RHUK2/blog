# Big O

- [단일 연결 리스트 (Singly Linked List)](#단일-연결-리스트-singly-linked-list)
- [이중 연결 리스트 (Doubly Linked List)](#이중-연결-리스트-doubly-linked-list)
- [단일 연결 리스트와 이중 연결 리스트의 비교](#단일-연결-리스트와-이중-연결-리스트의-비교)
  - [추가된 자료구조](#추가된-자료구조)
  - [참고 사항](#참고-사항)

## 단일 연결 리스트 (Singly Linked List)

구조:

- 각 노드에는 두 가지 정보가 저장됩니다:

1. 데이터(data)
2. 다음 노드로의 참조(next pointer)

- 노드는 한 방향으로만 연결되어 있습니다.

연산별 빅오 시간 복잡도:

| 연산          | 시간 복잡도      | 설명                                                                                                                                  |
| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 읽기 (Access) | `O(n)`           | 특정 인덱스에 있는 값을 읽기 위해서, 첫 번째 노드부터 순차적으로 탐색해야 합니다.                                                     |
| 삽입 (Insert) | `O(1)` (앞)      | 첫 번째 노드(리스트의 맨 앞)에 삽입하는 경우, 단순히 새 노드를 생성하고, 새 노드의 `next`를 기존 첫 노드에 연결하면 되기 때문에 O(1). |
|               | `O(n)` (뒤)      | 리스트의 끝에 삽입할 경우, 끝까지 탐색한 후에 새로운 노드를 추가해야 하므로 O(n).                                                     |
| 삭제 (Delete) | `O(1)` (앞)      | 첫 번째 노드를 삭제하는 경우, 단순히 헤더 포인터를 다음 노드로 변경하면 됩니다.                                                       |
|               | `O(n)` (중간/뒤) | 리스트의 중간이나 끝에서 요소를 삭제하려면, 삭제하려는 요소의 직전 노드까지 탐색해야 하므로 O(n).                                     |
| 탐색 (Search) | `O(n)`           | 원하는 값을 찾기 위해 리스트를 처음부터 순차적으로 검색해야 합니다.                                                                   |

---

## 이중 연결 리스트 (Doubly Linked List)

구조:

- 각 노드에는 세 가지 정보가 저장됩니다:

1. 데이터(data)
2. 이전 노드로의 참조(prev pointer)
3. 다음 노드로의 참조(next pointer)

- 노드는 양방향으로 연결되어 있습니다(앞으로도, 뒤로도 이동 가능).

연산별 빅오 시간 복잡도:

| 연산          | 시간 복잡도    | 설명                                                                                                                                 |
| ------------- | -------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| 읽기 (Access) | `O(n)`         | 특정 인덱스를 읽기 위해 리스트를 순차적으로 접근해야 하므로 O(n). 그러나 양방향 참조로 인해 필요 시 뒤에서부터 탐색할 수도 있습니다. |
| 삽입 (Insert) | `O(1)` (앞/뒤) | 리스트의 양 끝에 삽입할 때는 단순히 헤더나 테일 포인터를 조정하면 되므로 O(1).                                                       |
|               | `O(n)` (중간)  | 중간에 삽입하려면 삽입할 위치까지 탐색해야 하므로 O(n).                                                                              |
| 삭제 (Delete) | `O(1)` (앞/뒤) | 맨 앞 또는 맨 뒤 노드를 삭제할 경우, 헤더나 테일 포인터만 변경하면 되기 때문에 O(1).                                                 |
|               | `O(n)` (중간)  | 중간 노드를 삭제하려면 삭제 위치까지 탐색한 뒤 이전 및 다음 노드를 재연결해야 하므로 O(n).                                           |
| 탐색 (Search) | `O(n)`         | 단일 연결 리스트와 마찬가지로 순차 탐색이 필요하며, 값이 찾는 값에 따라 최악의 경우 리스트를 모두 순회해야 함.                       |

## 단일 연결 리스트와 이중 연결 리스트의 비교

| 특성                | 단일 연결 리스트       | 이중 연결 리스트           |
| ------------------- | ---------------------- | -------------------------- |
| 구조                | 단방향 연결            | 양방향 연결                |
| 메모리 사용         | 적음                   | 더 많음 (양방향 참조 추가) |
| 삽입 및 삭제 편의성 | 맨 앞 삽입/삭제는 유리 | 맨 앞/뒤 삽입/삭제 유리    |
| 탐색 방향           | 한 방향 (처음 → 끝)    | 양방향 탐색 가능           |

- 단일 연결 리스트는 메모리 사용량이 적고, 구현이 비교적 간단하다.  
  → 삽입, 삭제를 자주 수행해야 하고 방향성이 중요하지 않을 경우 적합하다.

- 이중 연결 리스트는 양방향 추적이 가능하므로 특정 위치에서 삽입/삭제가 더 빠르게 이루어질 수 있다.  
  → 복잡한 탐색(앞, 뒤로 이동)이나 양방향 탐색이 필요한 경우 적합하다.

자바스크립트 기준으로 주요 자료구조들을 비교한 표를 작성해 드리겠습니다. 요청하신 자료구조 외에도 자주 사용되는 몇 가지를 추가했습니다. 표는 각 자료구조의 특징, 주요 사용 사례, 시간 복잡도 등을 기준으로 정리했습니다.

| 자료구조    | JS 구현 방식                | 주요 특징                                                           | 시간 복잡도 (평균)                       | 주요 사용 사례                        |
| ----------- | --------------------------- | ------------------------------------------------------------------- | ---------------------------------------- | ------------------------------------- |
| Array       | `let arr = []`              | 순서가 있는 요소들의 집합, 인덱스로 접근 가능                       | 접근: O(1), 삽입/삭제: O(n)              | 순서가 중요한 데이터 목록 저장        |
| Object      | `let obj = {}`              | 키-값 쌍으로 데이터 저장, 순서 보장 안 됨 (ES6 이후 열거 순서 보장) | 접근/삽입/삭제: O(1)                     | 속성 기반 데이터 관리                 |
| Set         | `let set = new Set()`       | 중복되지 않는 값들의 집합, 순서 보장 안 됨                          | 삽입/삭제/탐색: O(1)                     | 중복 제거, 고유 값 관리               |
| Map         | `let map = new Map()`       | 키-값 쌍 저장, 키로 모든 데이터 타입 사용 가능, 삽입 순서 보장      | 삽입/삭제/탐색: O(1)                     | 키-값 쌍의 순서가 중요한 경우         |
| Stack       | Array 사용: `push`, `pop`   | LIFO(Last In, First Out), 배열로 쉽게 구현 가능                     | 삽입/삭제: O(1)                          | 함수 호출 스택, 뒤로 가기 기능        |
| Queue       | Array 사용: `push`, `shift` | FIFO(First In, First Out), 배열로 구현 시 비효율적일 수 있음        | 삽입: O(1), 삭제: O(n)                   | 작업 대기열, BFS 구현                 |
| Tree        | 커스텀 객체로 구현          | 계층적 구조, 노드와 엣지로 구성                                     | 탐색/삽입/삭제: O(h) (h는 높이)          | 계층적 데이터 (DOM, 파일 시스템)      |
| Heap        | Array로 구현 (보통 이진 힙) | 우선순위 큐 구현에 적합, 최소/최대 값 빠르게 추출                   | 삽입/삭제: O(log n), 최솟값: O(1)        | 우선순위 큐, 힙 정렬                  |
| Hash Table  | `Map` 또는 `Object` 활용    | 키를 해시 함수로 매핑해 값 저장, 충돌 가능성 있음                   | 삽입/삭제/탐색: O(1) (최악 O(n))         | 빠른 검색, 캐싱                       |
| Graph       | 인접 리스트/행렬로 구현     | 노드와 엣지로 구성, 방향/무방향 가능                                | 탐색: O(V + E) (V: 정점, E: 간선)        | 네트워크, 소셜 관계, 경로 찾기        |
| Deque       | 커스텀 구현 또는 Array 활용 | 양쪽 끝에서 삽입/삭제 가능 (Double-ended Queue)                     | 삽입/삭제: O(1)                          | 슬라이딩 윈도우, 양방향 큐            |
| Linked List | 커스텀 객체로 구현          | 노드가 다음 노드를 참조, 단일/이중 연결 리스트 가능                 | 접근: O(n), 삽입/삭제: O(1) (위치 알 때) | 동적 크기 조정, 삽입/삭제 빈번한 경우 |

### 추가된 자료구조

- Deque: 양쪽에서 삽입/삭제가 가능한 큐로, 자바스크립트에서 기본 제공되진 않지만 유용합니다.
- Linked List: 자바스크립트에 내장되어 있지 않지만, 동적 데이터 관리에 유리해 추가했습니다.

### 참고 사항

1. 시간 복잡도: 평균적인 경우를 기준으로 작성했으며, 최악의 경우(예: 해시 충돌)는 다를 수 있습니다.
2. JS 구현: 자바스크립트는 일부 자료구조(예: Tree, Graph, Linked List)를 기본 제공하지 않으므로, 객체 또는 배열을 활용해 커스텀 구현해야 합니다.
3. 빠트린 자료구조: 요청하신 목록은 대부분 포함했으나, 특정 도메인에서 사용하는 특수 자료구조(예: Trie, B-Tree 등)가 필요하면 말씀해주세요!

혹시 특정 자료구조에 대해 더 깊이 알고 싶거나, 표에 추가할 내용이 있다면 알려주세요!
